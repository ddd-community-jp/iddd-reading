## 序章 P.109~111

### :books:概要

- DDDの利点のひとつは、特定のアーキテクチャに依存しないこと。
- アーキテクチャは、あくまでも失敗のリスクを軽減するために使うためのもの。
    - 妥当な理由もないままにアーキテクチャスタイルやパターンを使い、逆に失敗のリスクを増やしてしまうようではいけない
    - 正当な理由を見つけるためには、機能要件がわからないといけない
    - ユースケース駆動でアーキテクチャを選ぶというソフトウェア開発が今日でも当てはまる
- アーキテクチャは過信しない。使い所を見極め、リスクを軽減できるであろう場合にだけ使う

### :question:疑問点
- P.110「エヴァンス本の執筆当時に流行していたアーキテクチャを題材にしただけのことであって、実際にはそれ以外のアーキテクチャでもちゃんと使えるものだということを理解するには時間を要した」とある
DDDを利用できるアーキテクチャとして選ぶ場合、どういう基準で選ぶのだろうか。

### :memo:書記欄
-

---

## 4.1 CIOへのインタビュー P.111~114

### :books:概要

- SaaSOvationのCIOへのインタビュー形式で、どのような場面でアーキテクチャの選択をし、どんな効果があったかが書かれている
    - 最初はデスクトップアプリを作る予定で、レイヤ化アーキテクチャを採用していた。
    - SaaS型の契約モデルに移行することを決めた際、品質を担保するためDIPの原則を導入し、DBなどはインメモリでテストを簡単にできるようにした。これによって、データの核の方法などに、どんな技術を採用するかの判断を先送りに出来た。
        - DDDの戦術的パターン（集約パターン、リポジトリ）を使っていたので、そこまで切替に苦戦しなかった。
    - モバイル端末などに対応をする際、ヘキサゴナルアーキテクチャへの移行を決めた
    - レガシーなコラボレーションデータを、自身のサービスへ移行するためのサービスとして、SOAを採用。
    - 障害追跡用のソフトウェアとして、TrackOvationを投入。その際には、CQRSを取り入れた。
    - 買収をされ、市場を独占したとき、コンプライアンス問題への対応として、イベントソーシングを採用していく。

### :question:疑問点
- 現実問題でこんなにアーキテクチャを変更するようなことあるのか。

### :memo:書記欄
-


## 4.2 レイヤ P.114~120

### :books:概要

#### 伝統的なレイヤ化アーキテクチャ

- 昔ながらのレイヤ化アーキテクチャを使った DDD のアプリケーションで一般的なレイヤは以下の通り。
  - ユーザーインターフェースレイヤ
  - アプリケーションレイヤ
  - ドメインレイヤ
  - インフラストラクチャレイヤ
- このアーキテクチャの本質的な原則は、**どのレイヤも、同じレイヤかその下位のレイヤとしか結合しない** ということだ。
  - 厳密なレイヤ化アーキテクチャは、直下のレイヤとの結合しか認めない。
  - 緩やかなレイヤ化アーキテクチャは、下位にあるどのレイヤとの結合も許可する(多くのシステムはこちらだ)。
- ユーザーインターフェースレイヤは…
  - ユーザーへの表示やユーザーからのリクエストに関するコードだけを書く。
    - バリデーションをする場合、ユーザーインターフェースでは荒いレベルのバリデーションにとどめ、業務に関する深い知識はドメインモデルの中だけで表現する。
    - 詳細については5章エンティティで説明される。
  - アプリケーションサービスの直接の利用者となる。
  - 外部システムから利用される場合、公開ホストサービス(OHS) で API を用意することもある。
- アプリケーションレイヤは…
  - モデル上のユースケースやユーザーストーリーを表現するための主な手段となる。
  - ドメインロジックを持たない **アプリケーションサービス** が属する。
    - トランザクションやセキュリティを管理したり、他システムへの通知やユーザー向けのメールを組み立てるなどのために使うことがある。
    - **集約** などのドメインオブジェクトに対する操作を調整したりする。
    - 下層のモデルがドメインイベントを公開している場合、
      イベントのサブスクライバを登録する(イベントの保存や転送を、アプリケーションの役割の一つとして扱う)。
  - アプリケーションサービスはできるだけ薄くしたほうがよい。
    P.116 のコードよりもずっと複雑化する場合、
    ドメインロジックがアプリケーションサービスに漏洩して、ドメイン貧血症を起こしている兆候である。
- インフラストラクチャレイヤは…
  - 伝統的なレイヤ化アーキテクチャでは最下層に位置する。
    - 永続化やメッセージングなどの機構が含まれる。
  - コアドメインモデルのオブジェクトと、インフラストラクチャを結合させないこと。

#### インフラストラクチャレイヤを最下層に置くと…？
  - ドメインレイヤが必要とする技術的なところを実装するのが難しくなる。
  - コードがテストしづらい。
  - なんとかできないか？ 
    - ==> 依存関係逆転の原則(DIP) を使うと改良できる。
  
#### 依存関係逆転の原則(DIP) を適用したレイヤ化アーキテクチャ
- DIP を使ったアーキテクチャは 図4-3 のようにまとめることができる。
  - インフラストラクチャレイヤ
  - ユーザーインターフェースレイヤ
  - アプリケーションレイヤ
  - ドメインレイヤ 
- 依存関係逆転の原則(DIP) の定義
  - 上位のモジュールは下位のモジュールに依存してはならない。どちらのモジュールも、抽象に依存すべきである。
  - 図4-3は図4-1から逆転していることを分かりやすくするため、インフラストラクチャレイヤを一番上にしている。
  - 抽象は、実装の詳細に依存すべきではない。実装の詳細が、抽象に依存すべきである。
- 下位レベルのコンポーネント(**実装**)は、上位レベルのコンポーネントが定義する **インターフェース(抽象)** に依存するべきである。
- 実現の手段としては、依存性の注入(DI) やサービスファクトリ、プラグインなどがある。


### :question:疑問点
- 「ドメインレイヤが必要とする技術的なところを実装するのが難しくなる。」の「技術的なところ」とは何なのか？　:+1:

### :memo:書記欄
- インフラ層とか、技術的なところ (実装手段) が、ドメイン層が依存してしまうので。DIPを使うと解決ができる。



---

## 4.3 ヘキサゴナル（ポートとアダプター）アーキテクチャ P.121~125

### :books:概要

- 図4-4のように、システムを**内部**と**外部**で捉える考え方。
- 様々な型のクライアントが、それぞれ自分用の[アダプター](https://ja.wikipedia.org/wiki/Adapter_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)を持っており、それがアプリケーションのAPIに合わせて変換をする。(P.121)
![](https://i.imgur.com/EFkEe5C.png)
- クライアントからのリクエストは、ポートを経由してアダプターに到達し、アダプターがApplicationを動かすための入力に変換をする。（P.122）
- またポートを経由してアプリケーションの出力をDBに格納したり、メッセージングなどで外へ出力する。(P.122)
- Applicationは、自身の公開APIを使ってリクエストを受け取る。
- アプリケーションの境界(内部の青い六角形)はユースケース（ユーザーストーリー）の境界でもある。
- ヘキサゴナルアーキテクチャを使う時は、ユースケースを念頭に置いてアプリケーションを設計する。（P.123）
    - サポートするクライアントの数を基準にはしない
- 出力側に関しては、永続化のためのアダプターとしてリポジトリの実装を考える(P.124)
    - リレーショナルデータベース用・ドキュメントストア用・分散キャッシュ用・インメモリストア用のリポジトリを実装して用意することになる
    - アプリケーションから外部にメッセージを送った場合は、メッセージング用のアダプターを用意する。
- ヘキサゴナルアーキテクチャの大きな利点は、テスト用のアダプターを簡単に作れる
    - アプリケーション全体とドメインモデルの設計やテストを、クライアントやストレージが確定しないうちから行えるようになる
- ヘキサゴナルアーキテクチャは、強力な基盤として、他のあらゆるアーキテクチャの追加に対応できる(P.125)
    - 本章ではこれ以降、この「ポートとアダプター」形式を使って開発を進める。
- 参考:[\[DDD\]ドメイン駆動設計で実装を始めるのに一番とっつきやすいアーキテクチャは何か \- Qiita](https://qiita.com/little_hand_s/items/ebb4284afeea0e8cc752)

### :question:疑問点
- ポートってなんでしたっけ？
- ヘキサゴナルアーキテクチャが、他のアーキテクチャを追加に対応しやすい、という理由がいまいちわかっていない。
- 新しいクライアントが、他のクライアントが今まで要求してなかったデータを要求した場合、ドメイン層に手を加えないといけないと思われ、結構大規模な改修になりそうだが、そこを見越してちゃんとユースケースをしっかり組み立てようね、という話なのか？



### :memo:書記欄
- ヘキサゴナルなら、この後に続くRESTやSOAやCQRSも取り込める。
- 色んな実装に対応ができるよ、的な
- アーキテクチャによっても粒度に差がある。
    - ソフトウェアアーキテクチャの内部構造の一つとして、レイヤードアーキテクチャスタイルを採用した　という関係。
    - サービス間のアーキテクチャスタイルの例として REST など。


---

## 4.4 サービス指向 P.125~128

### :books:概要

- サービス指向アーキテクチャ(SOA)という言葉は、人によって様々な意味で扱われている
    - 少なくとも「この議論ではこういう定義であるものとする」と定めておくことが大切
- この章では、Tohmas Erlが定めたSOAの原則を元にする。
    - 図4-1に示す８つの原則を備えている
- SOAマニフェストで宣言された優先項目にDDDをうまくあてはめるための、ひとつの方法に過ぎない（P.126）
- 第2章で議論したように、アーキテクチャがドメインモデルの大きさに影響を及ばさないようにしたい
    - 境界づけられたコンテキストの大きさが、RESTリソースやSOAPインターフェースに左右されてしまうようではいけない
    - そうした場合、小さな境界づけられたコンテキストが大量にできあがってしまい、それぞれのコンテキストの中にはエンティティが一つだけという状態になってしまう
    - そのような状態は、戦略的DDDの目標を実現したものになるとは限らない。
    - また、SOAマニフェストの思想に基づいているとも言えない
- SOAマニフェスト
    - ①技術的な戦略よりも**事業価値**を
    - ②プロジェクトの利益よりも**戦略的目標**を
- 参考：[「SOAマニフェスト」が発表、SOAの意味が再定義された － Publickey](https://www.publickey1.jp/blog/09/soasoa.html)



### :question:疑問点
- P127の「境界づけられたコンテキストの大きさが、なにかの技術サービスのエンドポイント、たとえばRESTリソースやSOAPインターフェースなどに左右されてしまうようではいけない」のあとに、**「そんなことをすると、小さな境界づけられたコンテキストが大量にできあがってしまい、それぞれのコンテキストの中にはエンティティがひとつだけという状態になってしまう」** という内容がよくわかっていない :+1::+1::+1::+1:
- アーキテクチャの章にSOAが入ってきたのかよく分からない　:+1:
- この節でいうサービスは、SOAのサービスであって、ドメインサービス・アプリケーションサービスとは関係ないという理解で良いのかな？

### :memo:書記欄
- RESTはリソース単位ごとに、PUT,POST,などが用意されている。
- /user　とか /document みたいなURI(リソース) の単位で、境界付けられたコンテキストにしてはいけない。
- ドメインレベルをまず考えるべき。RESTなどの技術単位でコンテキストを区切るべきではない。
- 
- いろんな設計手法(RESTとかSOAとか)とDDDをどのように対応付けるべきか、というのが4章の一つの目的なので、いろんな話題に関してDDDとの関係を書いてるのではないか、と思います。
- 




---

## 4.5 Representational State Transfer (REST) P.128~133


### :books:概要

>[REST](http://labo.mamezou.com/special/sp_013/sp_013_001.html)  
>ウェブのような分散ハイパーメディアシステムのためのソフトウェアアーキテクチャのスタイルのひとつ

RESTは設計に際し以下を設計原則とするよう提言されている。

- ステートレスなクライアント/サーバプロトコル
    - クライアント-サーバー間はステートレスな通信で実現する
    - 各HTTPメッセージには、対象のリクエストを処理するために必要な情報が全て含まれている
- すべての情報(リソース)に適用できる「よく定義された操作」のセット
    - インターフェース(HTTPメソッドの利用)の統一がされていること
        - GET(取得)
        - POST(登録)
        - PUT(登録または更新)
        - DELETE(削除)
    - これらの命令には標準的な振る舞いが定義されている
- リソースを一意に識別する「汎用的な構文」
    - アドレス指定可能なURIで公開されていること
- アプリケーションの情報と状態遷移の両方を扱うことができる「ハイパーメディアの使用」
    - HTML文書またはXML文書を使う

これらの原則に則ったWebサービスをRESTfulなサービスと呼ぶ。

ここでは、RESTの考え方とRESTfulなクライアント/サーバーの構築方法を学ぶ。

#### アーキテクチャスタイルとしてのREST

アーキテクチャにおけるアーキテクチャスタイルとは、**設計におけるデザインパターン**のようなものである。

- 具象実装を抽象化することで、技術的な詳細に振り回されない
- 抽象概念で語ることで、他のプロダクトにも適用できる

Web関連の技術はRESTが提唱される以前から存在してたが、RESTの登場により、標準化されHTTP 1.1の策定に大きく寄与した。これは、Webのプロトコルが柔軟性が高く、管理が難しくなったことに起因する。RESTfulであることのメリットを捨てることで得られること(さまざまな分散アーキテクチャに適用できるなど)もあるので、ProsConsを比較した上で選択するべきである。

#### RESTful HTTPサーバーのポイント

サーバ側を定義するときには3つのポイントがある

1. リソースの概念
    - 意味のある**モノ**として外部に公開するためにそれぞれ個別の識別子を付与する
    - アドレス可能性 : 一般的にモノにはURIを付与し、各URIが1つのリソースを指す
        - リソースには表現があり、状態の遷移も持つ
    - リソースには1つ以上のフォーマットがある
        - クライアントがリソースを使用するときに適切なフォーマットを選択する
        - リソース状態の表現に用いられるフォーマットは ~~RESTful準拠/非準拠なものまで~~- 様々
2. ステートレスな通信を実現するために、自己言及型のメッセージを使う
    - ひとつのHTTPリクエストに、サーバ側で処理するために必要な情報を含める
        - サーバ側の状態を永続化して、処理の手助けをすることもできる
    - **クライアントとサーバが暗黙のコンテキストを確立するために、個別のリクエストには依存してはいけない**
        - 各リソースへのアクセスが他のリクエストとは独立している
        - スケーラビリティの確保につながる
    - リソースをオブジェクトと捉える場合のインターフェイスは?
        (このブロックを間違えて消してしまったので書き直しました m(__ )m)
        - RESTが除荷の分散システムアーキテクチャスタイルと一線を画すところ
        - 統一インタフェース: あらかじめ定義された操作(動詞)のみ
            - GET, POST, PUT, DELETE
            - CRUD操作ではない
            - それぞれの動詞が満たすべき性質はHTTP仕様で定義されている
                - GET は安全である (冪等である)、など
3. RESTfulなサーバは、クライアントがサーバへの経路を発見できるようにする
    - HATEOAS (Hypermedia as the Engine of Application State)
        - アプリケーションの状態遷移エンジンとしてのハイパーメディア
        - ハイパーメディアのリンクを辿る操作をアプリケーションの状態変化と対応付ける
    - 接続性 : 辿れるべきリソース間はリンクで繋がっている

~~HTTPメソッドは厳密には、変更を伴わない「安全」な操作で、同じ処理を何回呼び出しても結果が変わらず問題も発生しない「冪等(べきとう)」な操作と言われている。~~

#### RESTful HTTPクライアントのポイント

RESTful HTTPクライアントは、あるリソースから別のリソースに移動する。

>リソースの表現に含まれたリンクもしくは、サーバーにデータを送った際の応答でリソースのリダイレクトするなどして、リソースを移動させる

サーバーとクライアントが協調して、クライアントの分散の振る舞いを動的にする。理想的なRESTでは、既知のURIに対してクライアントから最初のリクエストを送信したら、その後の制御はハイパーメディアに委ねる。

>RESTでは、ハイパーメディアを用いて、レスポンスの中に他のリソース情報を埋め込むことができる。Fielding氏の論文では、このことをHATEOAS(Hypermdia as the Engine of Application State)と呼んでいる

#### RESTとDDD

DDDとRESTfulを組み合わせる方法が2種類ある

- 再利用性を重視しない、特化したソリューションを構築する手法
- 汎用的なソリューションを目指し、標準規格による標準化を進める、メディアタイプ主導の手法

1. システムのインターフェイスレイヤを境界付けされたコンテキストとして分離し、適切な戦略を用いてインターフェイスのモデルから実際のコアドメインにアクセスする
    - システムのインターフェイスを全体として包括的に捉える
    - (ドメインオブジェクトを公開する) サービスやリモートインターフェイスを使わない
    - リソースによる抽象化を用いてインターフェイスを公開する
    - インターフェイスを介しているため、設計の変更に強い
        - コアドメインの変更がクライアントの変更に直結しない
    - 例:ical(一般的なカレンダー形式)のような汎用的なメディアタイプを使用する
    - 混じりけの無いドメインモデルを設計して、インフラ層の一層の詳細を分離する
    - クライアントのユースケースを反映したリソース群をリモートインタフェースとして提供する 
2. ドメインオブジェクトをJAX-RSリソースメソッドへのパラメータとして指定するなど、
   ドメインオブジェクトとリソースを同一視した実装 (Taskオブジェクトを戻すなど)をする。
    - ~~独自のモデルを設計する~~ 
    - 設計が変更する毎にクライアントに影響を及ぼす
    - 標準のメディアタイプを利用するときに採用する
        - 単純なインターフェイスをカバーする
        - さらに、あるカテゴリにおけるクライアント-サーバー間のやり取りを全てカバーする
    - DDDの共有カーネルや公表された言語に該当する


この2つの手法の選択するかは、「**システムの設計者が再利用性をどう考えるか**」で判断が分かれる。

- 前者:特化したソリューション
- 後者:汎用的なソリューションを目指し、標準規格による標準化を進める

#### RESTを選ぶ理由

~~RESTは~~ RESTベースのシステムは、疎結合で、拡張がしやすい。リソース単位に分割して扱えるため、理解しやすく、テストや利用がしやすい。スケーラブルなサービスの提供にも適している。そのため、DDDのヘキサゴナルアーキテクチャとの相性も良いとされている。

### :question:疑問点

- 「アーキテクチャスタイルとしてのREST」の要約「これは、Webのプロトコルが柔軟性が高く、管理が難しくなったことに起因する」は、本文のどこに対応するものか?
- 「RESTとDDD」の二つの手法と、メディアタイプの関連が分からない。リソース状態とその表現は独立したものなので、どちらの手法でもメディアタイプを選択することは可能だし、独自メディアタイプを定義・標準化することも可能なのでは。
- 「RESTを選ぶ理由」の要約「DDDのヘキサゴナルアーキテクチャとの相性も良いとされている」とまでは明言していないのでは。
- 本文に出てくるような厳密な(奇麗な) RESTを使って作られているサービスの例って知りませんか？:+1:
- 「RESTful HTTP サーバのポイント」のところで、「それぞれ、ひとつあるいは複数のフォーマットを持つ。クライアントがリソースを扱うときは、そのリソースの表現を利用する」というのは、PL（公開された言語）のこと？

### :memo:書記欄

- 冪等になっていないと、スケールしない問題。REST。
    - 冪等性が保証されないと、2回送信したらどうなるとか、セッション保持しないといけないとか。


## 4.6 コマンドクエリ責任分離（CQRS） P.133~142

### :books:概要

- いくつもの集約をまたいだデータ集約が必要となることがある。ドメインを洗練させるほど発生しやすい。
  リポジトリだけでできる下記のような対策もあるが、~~あまりやりたくない~~ どちらも使えない場合にはUXに妥協が必要になる。(P.133)
  - クライアント側で複数のリポジトリを使って、複数の集約からデータを取得してからデータ変換オブジェクト(DTO) に格納する。
  - リポジトリ上にファインダーを用意して、一回の問い合わせで各地のデータを取りまとめる。
- もっと違う方法でドメインのデータをビューにマッピングできないか？
  その答えが、コマンドとクエリの分離(**CQRS**) である。(P.134)
  - メソッドは、コマンドかクエリのいずれか一方でなければならない。
  - あるメソッドがオブジェクトの値を変更するのなら、
    そのメソッドは **コマンド** であり、値を戻してはいけない。(Java/C# なら戻り値はvoid)
  - あるメソッドが何らかの値を戻すのなら、そのメソッドは **クエリ** であり、
    直接・間接を問わずオブジェクトの状態を変更してはいけない。
- 通常は、コマンドとクエリの両方のメソッドを持つ集約やリポジトリが存在する。 
  CQRS では、こういった「普通」の状態は無視して、表示用のデータを違う方法で問い合わせる。
- `add()` や `save()` といったメソッドをコマンドモデルへ、
  `fromId()` のようなクエリメソッドをクエリモデル(**問い合わせを最適化するようにチューニングしたもの**) へ切り分ける。(P.134-135)
- CQRS を適用するとコードの量は増えて複雑になるが、
  **場合によっては**、複雑さを増してでもこのスタイルにしたほうがいいこともある。(P.135)

#### ■ 図4-6(P.135)
あったほうが、多分以下の説明わかりやすいかと思って。

![](https://i.imgur.com/vkAK619.jpg)


~~#### ■ CQRS の構成要素~~
#### ■ クライアントとクエリプロセッサ (P.136)
- WebブラウザやUIが、サーバー上で動いているクエリプロセッサ群を利用する。
- クエリプロセッサは、データベースに対する基本的な問い合わせしか知らない。
- クエリプロセッサの仕事は、DBに問い合わせてその結果を必要に応じて転送用のフォーマットにシリアライズすることくらいだ。
- シリアライズは、DTOにしてもいいし、XMLやJSONにしてもどちらでもよい。
  プロジェクトにとって最良の手法をチームで判断しよう。

#### ■ クエリモデル(リードモデル) (P.136-137)
- クエリモデルは、非正規化したデータモデルである。
- **表示用(印刷用) のデータだけを扱う** ものだ(※ドメインの振る舞いを伝えることを目的としない)。
- 仮にこのデータモデルがSQLデータベースだったとすると、
  **クライアントのビュー(表示内容) の種類ごとにテーブルを用意する (データベースのビュー機能を利用することもできる)** ことになる。
  - 例えばユーザー権限が複数ある場合…
    - 一般ユーザー向けのビューコンポーネントは (DBの)一般ユーザービューのすべてのカラムを読み込む、といったようにアクセス主体ごとにテーブル/ビューを分けることで、権限の異なるデータも適切に分けることができる。
    - 可能なら、select 文には、利用するビューの主キーだけしか指定しなくてもいいようにしておきたい。
  - データモデルの設計は、可能な限り、ユーザーインターフェイスの表示形式ごとにひとつのテーブルを用意するようにしたい。
    アプリケーションのユーザー権限を反映させたビューも必要なだけ用意する。
      - とはいえ、**あくまでも現実的な範囲にとどめる**こと。

#### ■ クライアントからのコマンドの実行 (P.138)
- ユーザーインターフェイスのクライアントは、サーバーにコマンドを発行して集約上の何らかの振る舞いを実行する。
- 発行したコマンドの中には、実行したい振る舞いの名前やパラメータなどが含まれる。
- コマンドモデルは、契約や振る舞いなどをきちんと考慮した作りとなっているため、コマンドとの対応は単純なマッピングとなる。
- したがってユーザーを正しく導いて、明確なコマンドを実行させるようにしなければいけない。
    - 帰納的でタスク主導のユーザインタフェース設計が最適

#### ■ コマンドプロセッサ (P.138-139)
- 発行されたコマンドを受け取るのがコマンドハンドラ(コマンドプロセッサ)である。
- いくつかの方式がある。
  - 分類方式
    - 複数のコマンドハンドラを一つのアプリケーションサービスで取り扱う方式。
    - シンプルになる。
  - 専用方式
    - 個々のハンドラは、単一のメソッドを持つ単一のクラスで構成され、このメソッドの契約が、特定のコマンドとそのパラメータを表す。
    - 他のハンドラとの依存関係を気にせず個別にデプロイできる。
    - 簡単に型を増やせる。
  - メッセージング方式
    - 個々のコマンドを非同期のメッセージとして送信し、専用方式で作られたハンドラにメッセージを配送する。
    - コマンド処理の負荷増大に対応できる。
    - 設計が複雑になるので、第一の選択肢とすべきではない。
- コマンドハンドラは一般的に、ごく限られた作業しかしない。
  処理の大半は、集約のインスタンスをリポジトリから取得して、そのコマンドを実行するだけである。
- コマンドハンドラの処理が完了したら、集約のインスタンスが更新されて、コマンドモデルがドメインイベントを発行する。クエリモデルを確実に更新するために欠かせない。
- ドメインイベントの送信に、なんらかのイベントキューサービスを使ったことがある方います？経験談を聞きたい。

#### ■ 振る舞いを実行するコマンドモデル(ライトモデル) (P.139-140)
- コマンドモデル上のメソッドが実行されるとき、最後にイベントを発行する。
    - このイベントについては8章(ドメインイベント) で説明される。
- BackLogItem のコマンドメソッドのコード例。
    - オブザーバパターン(詳細は8章) で作られた DomainEventPublisher でイベントを発行している。
    - このイベントで、コマンドモデルの直近の変更に合わせて、クエリモデルを更新する。
    - イベントソーシングなら永続化にも使用する。
    - ただし**イベントソーシングは CQRS で必須ではない**。

#### ■ イベントのサブスクライバによるクエリモデルの更新 (P.140-141)
- サブスクライバを作ってイベントを購読することで、コマンドモデルが発行するすべてのドメインイベントを受信させる。
- サブスクライバは受信したドメインイベントに沿ってクエリモデルを更新する。
- 同期処理にするか非同期処理にするかの判断は、求められるデータの整合性やパフォーマンス要件などが決め手になる。
    - 同期処理は、~~SLAは満たしやすいが~~ 一貫性を完全に保てるが、応答が処理完了まで待たされるため、SLAを満たせなくなる可能性がある。
    - 非同期処理は応答は速いが、結果整合性への対応が必要になるかもしれない。(バックかグラウンドでの) 処理が完了するまでに時間がかかり、UIへの反映は遅れるかもしれない。

#### ■ クエリモデルでの結果整合性の扱い (P.141-142)
- クエリモデルが結果整合性を持つ(非同期でクエリモデルが更新される) ように設計されている場合、UI が最新の状態にならないという想定をしておく方がよい。
    - あるいはコマンドのパラメータとして使った値を、一時的にUIに表示しておく設計もある。
    - これらが使えない場合、UI上に最終取得日時を表示しておく方法がある。
    - また UI に表示するデータの遅延が問題にならないこともある。
    - さらに Comet(Ajax Push) やオブザーバーの利用、
      分散キャッシュ/グリッド(CoherenceやGemFire) のイベント購読でもよいし、
      リクエストの受理とその結果の表示に時間がかかることを通知するだけでもよいかもしれない。
- CQRS を採用することによって失われるものもある。十分に検証して賢く使うこと。
- インターフェースがさほど複雑でもなく、単一のビューに複数の集約が絡むことが無ければ、下手にCQRSを導入しても、必要以上に複雑性を増す結果になる。
- CQRS が適切な選択肢となりうるのは、それによって、障害が発生する可能性の高いリスクを回避できる場合だ。


### :question:疑問点
- 図4-6にあるコマンドモデルの保存場所、クエリモデルの2つのDB？は、「コマンドモデルの保存場所」が、マスターみたいな考え方で良い？ :+1: 
    - 最悪、クエリモデルは破棄されても、コマンドモデルの保存場所から再生成できるような状態であればよいのか。
- P.141の「更新を同期させる場合は、クエリモデルとコマンドモデルで同じデータベース（あるいは同じスキーマ）を共有するのが一般的だ」と書かれている。ここでいうクエリモデルとコマンドモデルは、DAOのことを指している？ :+1: 
- 「CQRS を適用するとコードの量は増えて複雑になるが、場合によっては、複雑さを増してでもこのスタイルにしたほうがいいこともある。」の「場合によっては」とはどんな場合か？


### :memo:書記欄

- コマンドモデルがエンティティで、コマンドモデルの保存場所が、
- コマンドモデルとクエリモデルの関係性はいろいろある。
    - コマンドモデルがエンティティの形にある
    - クエリモデルはRDBのビューみたいな。
    - RDBと、ElasticSearchのログスタッシュという使い方もある。
- CQRSを導入する時は、EntityとRepositoryだけでやろうとすると、集約またぎの条件指定＆ページングしようとした時に無理になり、そういう場合には結局ジョインしてクエリ書かないとどうしようもなくなり、CQRSに手を出すことになる。


## 4.7 イベント駆動アーキテクチャ P.142~157

### :books:概要
- **『イベント駆動アーキテクチャ(EDA) とは、イベントの作成や検出、消費そしてイベントへの反応を促すアーキテクチャである。』**
- 図4-4に示すヘキサゴナルアーキテクチャの、三角形のクライアントと出力機構が、メッセージングシステムであったとして、以降の話は進める。
    - システムのイベントの出入りは、この三角形で表すことにする。
- イベントの中でも、ドメインイベントに着目する。
    - システムの稼働状況を管理するシステムイベントや、ログの記録や動的プロビジョニングなどのなどのイベントもあるかもしれないが、モデリングではドメインイベントにのみ気を付ける。
- 図4-7 は、複数のシステムがイベント駆動アーキテクチャで動作している例である。
- ただし **すべてのシステムをヘキサゴナルにする必要はない。**

#### ■ パイプとフィルター (P.144-148)
- メッセージベースのシステムは、パイプとフィルター形式を使っていることが多い。
- 最もシンプルなパイプとフィルター形式の実装は、シェル/コンソールにおける実装。
    - 例えば `cat phonenumber.txt | grep 303 | wc -l` とすることで、
        - `cat` ==> `grep`  ==> `wc` と順番に、
          パイプ(|) を経由して受け取った中身を編集して(フィルターして) 次へ受け渡すことで、
          最終的に、「テキストファイル中の`303` を含む行数」が出力される。
- EDA ではこのシェルにおけるパイプ(|) の代わりに、イベントとイベントハンドラを使ってパイプラインを作る。(図4-8, P.147)
    - 図4-8 + メモ (※ あまりにも頭に入ってこないので)
      ![](https://i.imgur.com/LakGh8f.png)
- 実際の業務に適用するなら、大きな処理を分割して分散処理するようにすればよい。
- 実際の DDD のシナリオでは、ステップ2から4は異なる境界付けられたコンテキストで発生するかもしれない。
- 詳しくは8章「ドメインイベント」で説明がある。



#### ■ 長期プロセス(サーガ) (P.148-154)

- **イベント駆動で分散型で、並列処理をするパターン** は『**長期プロセス(サーガ)**』と名付けられている。(P.148)
- 図4-8 の例を拡張して、長期プロセスのサンプルを見ていく(図4-9)。
    - 図4-9+メモ
      ![](https://i.imgur.com/TNslHgT.png)
    - 長期プロセス `PhoneNumberExecutive` は、
      ふたつのイベント `AllPhoneNumbersCounted` と `MachedPhoneNumbersCounted` の
      両方のイベントを受け取ってはじめて一連の処理が完了したと判断して、
      ふたつの処理の結果をまとめてログに出力する。
- 同じ処理の2通のイベントが同じ処理に関するものなのかを知るすべがない。(P.150)
  この対策としては、**プロセスごとに、一意な識別子を割り当てる** というものが第一歩である。
    - 一意な識別子を付与する方法は、5章「エンティティ」および8章「ドメインイベント」を参照。
- 実際のドメインでは、プロセスの実行者のインスタンスごとに、新たな集約を作ってステートオブジェクトとし、処理が完了するまでの状態を追跡する。(P.150)
    - プロセスの開始時に、関連するドメインイベントの一意な識別子と結びつける。
    - プロセスの開始時刻も保持しておくと役に立つ。
- このプロセスの状態追跡オブジェクト(ステートオブジェクト) が 図4-10 である。(P.150)
    - 一意な識別子と、`isCompleted` を持つことで、すべての並列処理の完了イベントを受け取ったかどうか判定できる。
    - メッセージングの仕組みによっては、各イベントが **たった一度だけ配送される** という保証ができない場合がある。
        - その場合、**既に完了済みでないかチェックして無視する**ようにしておくか、
          **冪等になるように設計して何回イベントが来ても同じ結果が返る**ようにする。
        - イベントの重複排除については、8章「ドメインイベント」を参照すること。
    - 完了の追跡をタイムアウトしたいこともある。
        - 受動的なタイムアウトは、イベントを受信した時にタイムアウトしていないかチェックすることで実現する。
        - 能動的なタイムアウトは、外部のタイマーを利用してタイムアウトをチェックすることで実現する。
- 長期プロセスでは、分散トランザクションについては打つ手がないので、結果整合性があればよしとする心構えが求められる。(P.153)
- 長期プロセスが有用なのは、レガシーシステムとの統合の時に、レガシーシステムのレイテンシが高くなる可能性がある場合などだ。(P.154)
- メッセージングシステムの中には、長期プロセスに対応する機能が組み込まれているものもある。(P.154)

---

- SaaSOvation の各チームは、境界付けられたコンテキストをイベント駆動アーキテクチャで扱うことにした。
- 長期プロセスで Product に関連付けられた Discussions の作成を管理する。

##### コラム: 長期プロセスの設計方法あれこれ(P.150)
    - プロセスを複数のタスクの組み合わせとして定義し、実行者コンポーネントに追跡させる。
    - プロセスを集約群として定義し、アクティビティ群の中で強調させる。
      ひとつあるいは複数の集約のインスタンスが実行者として働き、プロセス全体の状態を管理する。
    - ステートレスなプロセスを設計し、イベントを運ぶメッセージを受け取るメッセージハンドラが、
      受け取ったイベントにタスクの進捗状況を追加したうえで、次のメッセージを送信させるようにする。

#### イベントソーシング(P.154-157)

- ドメインモデル内のオブジェクトに発生する変更を、逐一追跡するような要件が出てくることもある。
    - ありがちな例は、最終更新日や最終更新者を追加するというもの。
- もっと細かく追跡したければ、Git などのように、イベントによる変更点を管理すればよい。
- イベントストアへすべてのイベントを保存しておき、最初のイベントから発生順に適用することで、過去の操作を再現できる。
- 最初から適用すると遅すぎる場合、バックグラウンドプロセスなどで集約の状態を **スナップショット** としてイベントストアに格納しておき、そのスナップショットとそれ以降の操作を適用すればよい。
- ビジネス的なメリットは…
    - イベントストアを修正してバグ修正できる
    - モデルへの変更の取り消しややり直しができる。
    - 仮想のシナリオを実際の履歴データで検証する。仮説検証に使える(BIにも使える)。
- 「付録A」で、集約とイベントソーシングを組み合わせた詳細な実用例が示されている。


### :question:疑問点
- ドメインイベントというのは、例に挙げるとしたらどんなものがあるか
~~- AWS LambdaやGCP Cloud Functionsなどがアダプターにあたる？~~　=> 別の所への質問でした。
- 疑問というより感想ですが、パイプとフィルターあたりを見ていて、リアクティブプログラミング（Rx）に近いのかなと思いましたが、この認識は合っている？
- 長期プロセスの図4-9が直列っぽいけど、どこが並列で分散的なんだろう？
- クラウドサービスで実装するとしたら、どういう感じになりそう？ :+1: 
- 「たとえば、EDAにおけるフィルターは、実際には何もフィルタリングの必要がない。EDAにおけるフィルターの役割は、何らかの処理をしている間、メッセージを傷つけないように保つことだ。」のメッセージを傷つけないとはどういう事か良くわからなかった。on パイプとフィルター (P.144-148)
- 前節のESでも思ったのですが、記録しているドメインのモデルが途中で変わる場合はどんなふうに対処するのですか？
- 長期プロセスを使いたくなる例や、実際に使われている例をご存じの方いませんか？ :+1: 
- 正直全体を通して良く分からなかったけど、pub/subと関連が近いのかなと思ってたら全然出てこなかったんですが、全然関連が無いものなんでしょうか？
- イベントソーシングにしたとき、イベントはシステム稼働時からずっと残しておかないといけないんでしょうか？



### :memo:書記欄


- オブジェクトを作る、オブジェクトを変更するなどは、ドメインイベントになりそう。
    - 何かしら変更があった場合、はすべてになりそう。
    - 基本的に Entityに備わる振る舞いに対応していると思います
    - バッチが何時何分にキックされた、というシステム的な情報は含めない。
- Rxの話
    - 実現の手法としては使えそうだけど、近くはないと思う。
    - 近くない。
- 長期プロセス
    - Event
    - 分散処理 = ・キューなどにいれることで、処理を分散させて、ひとつの処理を複数同時に処理させる。
                ・たは event 単体で処理をしているから分散    
    - 並列処理 = ひとつのイベントで異なる複数の処理が、並列に動作する。

- クラウドサービスで実装するなら
    - Azure
        - Busとかなら、Function→
    - AWS
        - SQS とかつかう
    - キューを使わない方法もある。
        - Pub/Sub の仕組みを使う
    - 同期/非同期
        - 非同期だとバグる可能性がたかい

    - Pub/Sub
        - TotalPhoneNumbersCounter
        - PhoneNumberFinder
        - こちらが2つのサブスクライバーがいる
        - まずは同期的に、やるだけでも依存関係を残せる。

    - 長期プロセス
        - これらのシンプルなやつを、非同期にした感じ
    - Domain Event
        - Domain Eventは発行する側が、ただ投げるだけ。
        - 同期的なEventは結構処理的にあり
    - Aの処理の中で、Eventで、Bの処理を行うというやる感じ。
        - 集約またぎで、更新する場合には整合性を保つ。
        - ただ、アプリ層から見ただけではわからない。

    - メッセージを傷つける？
        - メッセージの改ざん的な、
        - 新たなイベントを発行するとキレイになりそう。
            - 元のメッセージは引き継ぐ感じになるかもしれない。
        - 発行したイベントはそのままの状態で全て保持する必要があると思います。
        
    - イベントソーシングの話
        - コマンド側が、所属を変えたというイベントを保持しておけばいい。
        - ユースケースに跳ねる可能性。
        - Pub/Subでイベントを拾うのは、すでにESっぽい
            - それはチョット違うように気がしている。
            - Eventだけを送って、購読者が状態を変更をする。
            - 3→5というEventを発行する
            - 購読者が何をするかはまた自由

        - Event StoreにEventをひたすら積み続けるのが、ES。
        - イベントストア自体は、必ず順番は保証する。必ず1回
        - イベントソーシング用のライブラリがあるらしい。
            - https://eventstore.org/docs/http-api/index.html
        
        


---

## 4.8 データファブリックおよびグリッドベース分散コンピューティング P.157~162

### :books:概要

ビッグデータなどの巨大な情報システムを構築するための方法として、スケーラビリティを提供する仕組みとしてデータファブリック(グリッドコンピューティング)がある。グリッドコンピューティングは次の特徴を持つ。

- ドメインオブジェクトを永続化してキャッシュに保存する
- マルチレプリケーションにより性能面での管理が容易
- イベント駆動における送信保証のサポート
- キャッシュ変更時のプッシュ通知（ビューの即時変更）する
- 長期プロセスのような分散並行処理の管理

グリッドコンピューティングはドメインモデルとの親和性が高い。

- 分散キャッシュは、ドメインオブジェクト全般の永続化に対応
- 集約ストアとしても機能する
    - ファブリックのマップベースにキャッシュを格納する
    - キーバリューペアにおけるバリューに対応する
    - 集約の一意な識別子からキーを作成する
    - 集約の状態そのものを何らかの形式にシリアライズし、値として保存する

#### データのレプリケーション

| 用語 | 説明 |
|----|----|
| アーカイブ | 後の参照用に作成する特定のデータの集まり<br>長期保管のためにデータをコピーしておく<br>また、後から変更されないことが前提になっている |
| バックアップ | 現在の状態のデータのコピー<br>システム障害時などに直前の状態に戻すために利用する<br>完全性という意味では最も確実な方法だが、バックアップを取った時点までしか戻れない |
| レプリケーション | 機能の冗長化<br>同じ機能を持つサーバーを複数台用意し、データをリアルタイムにコピーする技術<br>主系に障害が発生しても従系の切り替えることで、機能を継続して提供する |

冗長化の仕組みをファブリックに実装することで、キャッシュに障害が発生しても状態を復元することができる。

つまり、単一の集約キャッシュは、極めて脆弱で、単一障害点になる。そこで、マルチキャッシュとレプリケーション機能を提供することで信頼性が極めて向上させることが出来る

#### イベント駆動のファブリックとドメインイベント

ファブリックの一番の機能は、**イベント駆動形式における送達保証のサポート**である。つまり、キャッシュレベル及びエントリレベルでイベントの発生を自動的に通知する。

>ドメインイベントとは違い、キャッシュの再初期化(キャッシュレベル)やエントリの作成や更新(エントリレベル)を通知

#### 継続的クエリ

>継続的クエリ  
>クライアントがファブリックにクエリを登録して、そのクエリを満たすキャッシュの変更通知を受け取る仕組み

CQRSでクエリモデルをファブリックで管理している場合は、継続的クエリを適用可能である。

#### 分散処理

データファブリックの利用方法の1つとして、レプリケートされたキャッシュをまたがる分散処理を実行し、取りまとめた結果をクライアントに返す手法がある。この方法を適用することで、ファブリックにイベント駆動の分散並列処理を提供することが出来る

```java
public class PhoneNumberCountSaga extends FunctionAdapter {
    @Override
    public void execute(FunctionContext context) {
        Cache cache = CacheFactory.getAnyInstance();
        QueryService queryService = cache.getQueryService();
        String phoneNumberFilterQuery = (String) context.getArguments();
        ...
        // Pseudo code
        // - Execute Function to obtain MatchedPhoneNumbersCounted.
        //   - Send answer to the aggregator by invoking the
        //     aggregator.sendResult(MatchedPhoneNumbersCounted).
        // - Execute Function to obtain AllPhoneNumbersCounted.
        //   - Send answer to the aggregator by invoking the
        //     aggregator.sendResult(AllPhoneNumbersCounted).
        // - The aggregator automatically accumulates the answers
        //   from each distributed Function call and returns the
        //   single aggregated answer to the client.
    }
}
```

- コマンドパターンを適用してハンドラを実現する
- レプリケートされた分散キャッシュをまたがって分散並列処理を実現する
    - ドメインを中心とした作業ではない
    - 複数のドメインにまたがった機能を提供
- サンプルコードに示すように並列処理結果を集約して出力する

### :question:疑問点
- データファブリックとは、特定の製品から生まれたっぽい？ 
    - https://pivotal.io/jp/pivotal-gemfire

- 今でいうと、Azure Service Fabric のような、クラウドサービスを使ったデプロイや保存などのサポートをしてくれるサービス・・のことなのだろうか？
- クラウドとかのAWSのDynamoDBっぽい？
- AWS、Azure、GCP で言うところのどんなサービスなんだろう？


### :memo:書記欄

- 

---

## 4.9 まとめ P.162~163

### :books:概要

DDDは様々なアーキテクチャに適用することが出来る。つまり、DDDは多用途性があるといえる。

- レイヤードアーキテクチャに依存性逆転の原則を適用することで、構造を改善できる
- ヘキサゴナルアーキテクチャの概要
    - アプリケーションのアーキテクチャ全体を包括的に扱う
    - ポート&アダプター形式に機能を追加する
- DDDをSOAの環境やRESTと組み合わせる
    - データファブリック
    - グリッドコンピューティング
- イベント駆動の概念
    - パイプとフィルターパターン
    - 長期プロセス
    - イベントソーシング

### :question:疑問点
- 

### :memo:書記欄

- 

---


## 輪読会感想ふりかえり用

- 日本語が意味わからん
- アーキテクチャの粒度の大小とかが、結構バラバラ
- サマリがかなり苦しい
- 俺たちの戦いはこれからだ！

## 読書会進め方ふりかえり用

- Kobayashiさんが一緒に司会をやってくれたのが助かる
- サマリーは、特に分担せず、空いてる箇所を書くくらい。

## その他、メモとか用の領域


