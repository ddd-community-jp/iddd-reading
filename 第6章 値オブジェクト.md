## 6.1 値の特徴
### :books:概要
- 計測・定量化・説明
  - モデルの中に真の値オブジェクトがあるなら、あなたが認識しているか否かにかかわらず、その値はドメイン内にあるモノではない。それは概念であり、ドメイン内にあるモノを計測したり定量化したり、あるいは何らかの形式で説明したりした結果にすぎない。
    - 人の年齢はモノではない。その人が生まれてから何年経過したのかを計測し、定量化した値だ。
    - 人の名前はモノではない。その人が何と呼ばれているかの説明だ。
  - 計測・定量化・説明の特徴は、概念的な統一体(Conceptual Whole)の性質とも密接に関連する。
- 不変
  - 値オブジェクトは、いったん作ったら変更できない。
  - JavaやC#なら値クラスのコンストラクタでインスタンスを作るときに、すべてのパラメータを渡して値の状態を組み立てる。
  - インスタンスを作って初期化が済んだら、それ以降は、その状態を変更できるメソッドは(public, privateを問わず)一切ない。
  - 値オブジェクトの中でエンティティへの参照を持つこともできる。しかし、その場合は注意が必要だ。エンティティの状態が変わったときにそれを保持している値も変わってしまうのなら、値の不変性に違反することになってしまう。
    - 値オブジェクトのインターフェイスを通してエンティティの状態を変更させようと考えているのなら、おそらく使い方を間違えている。



- 概念的な統一体(Conceptual Whole)
  - 値オブジェクトはひとつあるいは複数の属性を保持しており、それらがお互いに関連している。各属性が重要なパーツとなり、それらが全体として、値について説明している。他と切り離して属性単体として見ると、意味のある内容が得られない。すべてが合わさって初めて、計測値や説明として意味をなすものとなる。
  - 単に属性をまとめただけで、それ全体がモデル内の何かを的確に表しているのでなければ、まとめること自体にはあまり意味がない。
  - 親オブジェクトからの値オブジェクトへの参照は、単なる属性などではない。これは、親のオブジェクトのプロパティであり、モデル内のあるモノへの参照を保持しているものだ。
  - 値クラスのコンストラクタは、概念的な統一体の有効性を示す。値クラスのコンストラクタに求めるのは、不変性に加えて、一度の操作で完結した値を作成できるような手段を提供することだ。
- 交換可能性
  - モデル内のエンティティが、不変な値を参照として保持している場合、その値は現在の完結した値の状態を正しく表したものでなければいけない。もしそうでなくなったなら、値全体を新しいもので置き換えて、現在の正しい状態を反映させる必要がある。
  - 交換可能性という概念は、数値について考えると容易に理解できる。totalの値が現在3となっているが、これを4にする必要が出たとき、3という整数値を直接変更して4にしたりはしない。単純に、totalに改めて4という整数値を代入するだけのことだ。
  - 仮に整数値よりもずっと複雑な値オブジェクトだったとしても、置き換えはこれと全く同じようなことだ。少し複雑な値型を扱った、次の例を見てみよう。
```
FullName name = new FullName("Vaughn", "Vernon");
...
name = new FullName("Vaughn", "L", "Vernon");
```
  - コラム
    - オブジェクトの属性を変更する必要があるからという理由でエンティティを作ろうとしているのなら、まずはそれが本当に正しいモデルなのかどうかを疑ってみよう。属性の変更ではなく、オブジェクトの置き換えでも対応できるのではないだろうか？
    - 扱っているオブジェクトが複雑で、頻繁に変更されるものだとしても、まるごと置き換えるのが必ずしも非現実的だとは限らないし、不格好になるとも限らない。
- 値の等価性
  - 値オブジェクトのインスタンスを別のインスタンスと比較するときには、オブジェクトの等価性をたしかめる方法を利用する。システム全体を通して、等しいけれども同じオブジェクトではない値は、いくらでも存在するだろう。
  - 等価性を判断するには、二つのオブジェクトの型と、それぞれの属性を比較する。型が等しく、かつすべての属性も等しければ、二つの値は同じものだとみなす。
  - (実装例: nullチェック、クラスが同じこと、各属性が等価かをチェック(属性のnullチェックが抜けてる気がする))
- 集約(10)の一意性をチェックするために、値のどの特徴が必要になるか。(集約の識別子をValue Objectで表現できるかの話)
  - 値の等価性は、集約のインスタンスを識別子で特定するために必要。
  - 不変性も必要。一意な識別子は変わってはいけない。
  - 概念的な統一体という特徴にも助けられるだろう。識別子はユビキタス言語にのっとって命名されるものであり、一意に特定するために必要なすべての属性を、単一のインスタンスに保持するからだ。
  - 交換可能性は、識別子にとっては不要な性質だ。識別子は置き換えられることはない。
- コラム
  - 設計している概念が、他のオブジェクトとは区別して一意に識別スべきエンティティなのか、あるいは値の等価性を確認できればそれで十分なのかを考えてみよう。
  - 識別子が不要なら、値オブジェクトとして扱おう。

- 副作用のない振る舞い
  - オブジェクトの振る舞いは、副作用のない関数として設計できる。関数とは、オブジェクトに対する操作のうち、何かを出力するけれども自身の状態は変更しないものを指す。
  - 不変な値オブジェクトのメソッドはすべて、副作用のない関数でなければいけない。
  - Bertrand Meyerは、コマンドクエリ分離原則(CQS)において、副作用のない関数のことをクエリメソッドと呼んでいる。クエリメソッドとは、オブジェクトに対して問いかけるメソッドのことだ。その定義上、オブジェクトに答えを聞くことで、その答えが変わってしまってはいけない。
  - Value ObjectがEntityを引数として受け取り、計算をして値を変える、というのは問題がある。Entityの状態を変更していないか判断できない、などの理由。
  - 代わりに、Value Objectのメソッドにわたすオブジェクトを、Entityの代わりにValue Objectにすればいい。そうすれば、副作用のない振る舞いを良く表現できる。これはそんなに難しいことではない。
- コラム
  - あらゆるものを値オブジェクトとして扱うのはやりすぎ。特別な機能は不要なら、無理にラップする必要はない。

### :question:疑問点
- P.212 「値オブジェクトの中でエンティティへの参照を持つこともできる。しかし、その場合は注意が必要だ〜」と書かれているが、そういったことをやるパターンを思いつかない。このパターンを使うときが何かありそうか？　エンティティが値オブジェクトを持つことはあるだろうけど……。

  - ==>  RootEntity から他のEntityを紐付けるときなどが考えられる。


### :memo:書記欄
-

---


---

## 6.2 ミニマリズムを考慮した結合
### :books:概要
- 上流のコンテキストからオブジェクトを受け取るときは、可能な限り、下流のコンテキスト側でのその概念のモデリングには値オブジェクトを使うようにしよう。そうすれば、ミニマリズムを優先した統合ができる。つまり、下流のモデル内で管理すべきプロパティの数を最低限にできる。不変な値を使えば、責務も少なめに抑えられる。

### :question:疑問点
- 図6-1の下あたりの「ここでポイントとなるのは、上流の認証・アクセスコンテキストにある集約が多数の属性を保持しており、コラボレーションコンテキストに対して与える影響を最小化できることだ」という文章は、「上流の集約が多くの属性を持ってたらなんで影響を最小化できるんだ？」と感じてしまうが、これは誤訳。
  - 原文: the important point being the minimized impact that multiple Aggregates in the upstream Identity and Access Context, possessing many attributes, have on the Collaboration Context.
  - 再訳: 重要な点は、多くの属性を処理する上流の認証アクセスコンテキストの複数の集約がコラボレーションコンテキストに与える影響を最小限に抑えることです。
- 図6-2の説明の「上流のコンテキストが保持するのはUserのいくつかの属性だけで」は誤訳。
  - 原文: Only a few User attributes are retained from the upstream Context, 
  - 再訳: Userのいくつかの属性を上流のコンテキストから受け継ぎ、


### :memo:書記欄
- たぶん、Modelatorを値オブジェクトとして扱っているので、影響を最小限している
- 結果として、最小化したんじゃなくて、最小限に防ぐことが重要だと
- 認証・アクセスコンテキストにある Userの属性の幾つかの値だけが、コラボレーションコンテキストに渡される必要のあるものとしてコピーされて与えられている、ということを言いたい文章でしょう。

---

---

## 6.3 標準型を値として表現する
### :books:概要
- 多くのシステムやアプリケーションでは、いわゆる標準型が必要になる。標準型とは、何かのモノについて説明するためのオブジェクトで、その型を表している。
- 例: ユビキタス言語の中でPhoneNumberが定義されていて、その種類についての説明も必要になったとする。電話番号の種類を表す標準型を用意して、Home、Mobile、Work、Otherで表す。
- 例: Currency型を用意して、通貨単位の制約を付加する。
- 例: 調剤の研究開発のライフサイクルの管理として、開発の状態を表現するために標準型を使う。それ以外の手を使う選択肢もある。
- どのレベルで標準化するのかによって、これらの型をどこで管理するのかも変わる。アプリケーションレベルで管理すればいいのか、全社共通データベースで共有することになるのか、あるいは国の標準規格や国際標準規格に従うことになるかもしれない。標準化のレベルの違いが、モデルからの標準型の取得方法や使い方に影響を及ぼすこともある。
- もし**あなたの**境界づけられたコンテキストの中でその型のライフサイクル中の変更(標準型が増えたり減ったり名前が変わったり)を追い続ける必要がないのなら、値としてモデリングしよう。
- 保守性を考慮して、標準型を個別のコンテキストにしておくことがよくある。それを利用する側のモデルとはコンテキストを分けておくということだ。
- 集約を標準型として用いることもできるが、注意が必要。標準型は一般に、それを利用する側の境界づけられたコンテキスト内で管理するものではない。
- 共有の不変な値オブジェクトは、隠された永続化ストアから取得させることができる。標準型のサービスやファクトリから取得するなどの選択肢が考えられるだろう。
- 結局のところ、個人的には、enumを使って標準型を表現するのが最適なのではないかと考えている。
- Javaのenumは、標準型をサポートする手段として最もシンプルなものだ。
  - Javaのenumで表現したこのサンプルの標準型は、本質的には、すっきりとしたステートオブジェクトでもある。
- パワータイプ: インスタンスがクラスのサブタイプを表すようなクラスのことをパワータイプというそうです。
  - 例: 「新幹線の種類」クラスに対して「300系」「500系」「700系」「N700系」「N700系A」「E5系」というインスタンスを作る。

### :question:疑問点
- 6.3の冒頭でタイプコードやルックアップという名前をディスってるけど、標準型っていう名前もそんなにいい名前じゃないと思う(小並感)。ググってもあまり使われてなさそう。他に呼び名があったりするでしょうか？
- 以前はプルダウンの選択肢を何も考えずにDBに入れて使ってましたが、項目の追加やプログラムで条件を書くのにコストがかかるため、今は可能な限りenumで済ませてます。みなさんはどうされていますか？
- 「ステートパターンは有害なのか？」というコラムがありますが、ステートパターンに悪い感情を持ってなかったので、嫌っている人もいるということが意外でした。嫌いな理由があれば教えてほしいです。


### :memo:書記欄
- 標準型、いい名前でもないというのには同感。
    - そこまで気にしなくていい存在だと思われる
- 以前はプルダウンの選択肢を何も考えずにDBに入れて使ってましたが、項目の追加やプログラムで条件を書くのにコストがかかるため、今は可能な限りenumで済ませてます。みなさんはどうされていますか？
    - enum or const
    - ユーザーが画面から追加するならDB、そうでなければコードに実装っていう分岐なのかなぁと

- ステートパターンは有害なのか？
    - ニュートラルな人が多い。
    - ケースバイケース

---

---

## 6.4 値オブジェクトのテスト
### :books:概要
- ドメインモデルのテストで注目したいのは、クライアントからどのように使われるのかということと、クライアント側がそれらのオブジェクトに何を期待しているのかということだ。本質的な概念をとらえてモデルを設計する際に重要なのは、クライアントからの視点を気にすることだ。さもないと、私たちの一方的な観点にもとづいたモデルになってしまい、業務の視点が反映されない。
- (コラム)この手のテストについては、「モデルの利用者向けマニュアルを書いているとして、このドメインオブジェクトをクライアントpからどのように使うのかを表すコード例を用意する」と考えればいい。
- 不変性をテストするための手段を思いついた。
  - 最初にコピーコンストラクタで値オブジェクトをコピーする。
  - 処理を実行して、計算結果が正しいことを確認する。
  - その時、コピー元とコピー先の値オブジェクトがこの時点でも等しいことを確認する。
- (コラム)モデルのテストは、ドメインエキスパートにとって意味のあるものでなければいけない。
### :question:疑問点

- 値オブジェクトまでテストをするのって結構コスト高いのかなっていう気持ちではありますが、この辺りはプロジェクトによるんですかね？


### :memo:書記欄
- ユースケース単位でやる人が多い
- 振る舞いがあるなら、やる
- ケースバイケース
- 複雑になったらやっていく
- エンティティだとテストケースが増えるので、値オブジェクトに振る

---

---

## 6.5 実装
### :books:概要
- 各テストメソッドを作って、チームはクライアントがBusinessPriorityをどのように使うのかをより深く理解した。そして、そのあるべき姿をテストでたしかめられるような実装を行えた。
- 値型は、Serializableを実装するように宣言した。いずれ、この値のインスタンスのシリアライズが必要になるときがくるだろう。
- 私は通常、値オブジェクトを作るときには少なくとも二つのコンストラクタを用意することにしている。
  - 一方のコンストラクタは、状態の属性を設定するために必要なすべてのパラメータを受け取るものだ。基本属性の初期化には、privateなセッターを用いる。
  - もうひとつのコンストラクタは、既存の値をコピーして新しい値を作るために使うもので、コピーコンストラクタと呼ばれる。
  - このコピーコンストラクタが、ユニットテストを行う上で重要になる。値オブジェクトをテストする際には、それが不変であることもたしかめたい。
- ストラテジー/ポリシーの実装。この時点では、ストラテジ用のセパレートインターフェイスは用意していない。今の所、実装がまだひとつだけしか存在しないからだ。しかし、今後この状況が変わることは間違いない。アジャイルプロジェクト管理ツールのユーザー用には、別の優先順位算出方法が用意されるだろう。そしてそのそれぞれについて、ストラテジの実装が必要になる。
- JavaBeanの命名規約にあるgetプレジックスを使うことは意図的に割けた。getValuePercentage()はいかにもコンピューター的な言い回しだが、valuePercentage()なら、人間が使う言葉に近くなる。
  - JavaBeanの仕様は、オブジェクトの設計に多大な悪影響をおよぼしたと私は思っている。
- 有効なパラメータについての表明のことを、ガードと呼ぶ。明らかにおかしなデータへの対応を迫られないように、そのメソッドをガードするからである。
  - 文中のrating() メソッドは、引数がnullなら IllegalArgumentExceptionを投げる形でガードしている。
### :question:疑問点
- (P.235) コピーコンストラクタで値オブジェクトをシャローコピーしたい時、というのはどういう時なんだろうか？値オブジェクトなら中身を共有してもOKという理屈がよくわからない。



### :memo:書記欄
- 深く気にしないことにしました。笑

---

---

## 6.6 値オブジェクトの永続化
### :books:概要

- 値オブジェクトのインスタンス化の永続化については、様々な方法があるが、何らかのテキスト形式（あるいはバイナリ形式）にして、ディスクに保存することになるだろう
    - 個別の値のインスタンスを自力で永続化させることには関心がない
    - 値だけではなく、それを含む集約の状態も含めて永続化する方法に注目する
    - この章で説明する手法は、親のエンティティが、永続化させる値のインスタンスへの参照をすべて保持していることを前提とし、集約を追加したり、読み込んだりといった操作は、リポジトリ経由で行っているものとする
    - そこに含まれる値の永続化や復元は、集約ルートとともに、裏側で行われる
- ORMを使ってすべてのテーブルにマッピングすると、複雑になっていきやすい
- NoSQLデータベースやキーバリューストアという選択肢もある
    - キーバリューストアを使えば、集約の永続化がずっとシンプルに表現できるようになる
        - NoSQLとキーバリューストアの相性抜群のため、12章のリポジトリで解説する
    - ここではORMベースの永続化を取り上げる

- ドメインモデリングと対象的なデータモデリングが、ドメインモデリングにどんな悪影響を与えるのか

- データモデルが漏れることによる影響を排除する
    - ドメインモデルとデータモデルのインピーダンスミスマッチに遭遇したときには、ドメインモデルの視点を保ち続ける
    - P238に4つの質問があり、「性質についての説明、イエス、イエス、ノー」だった場合は、値オブジェクトを使うべきである

- P.239 永続化視点で考えてしまうと、ドメインモデルが単なるデータモデルの写像になる可能性がある
    - （ドメイン貧血症みたいなことになるか）

- ORMでの単一の値オブジェクトの扱い
    - 単一のオブジェクトを非正規化して、親エンティティの行に組み込むことになる
    - P.24０に、Hibernateとコンポーネントマッピングについての例が書かれており、BussinessPriorityという値オブジェクトを永続化する例が書かれている
        - カラム名の付け方の一例としては、`bussiness_priority_rationgs_benefit`など、実際の親モデルから個々の属性へのパスみたいな付け方をしている。

- ORMでの、複数の値をシリアライズした単一のカラムの扱い
    - 1エンティティが、値のコレクション（List、Setなど）を保持している場合、インピーダンスミスマッチがかなり目立ってくる。
    - ORMで使える選択肢の1つで、オブジェクトのコレクション全体を、テキスト形式にシリアライズして、単一のカラムで永続化させること
        - 欠点としていくつか
            - カラムのサイズ：コレクションのサイズがわからない以上、上限を超える恐れあり
            - 問い合わせの条件：値をテキスト形式にして、1つのカラムに収めるため、SQLを使って値のコレクションへの問い合わせができない。
            - カスタムユーザー型が必要：各コレクションのシリアライズと復元を用意しなければいけない

- ORMでの、複数の値をデータベースのエンティティに格納する場合の扱い
    - レイヤスーパータイプを使い、値オブジェクト自体に代理識別子を付与する。
    - P.246の例では、GroupMemberという値を、Groupというルートエンティティが持つような構成にしてあり、それをマッピングしている。
    - ｔｂl_groupとtbl_group_memberと２つのテーブルを定義している

- ORMでの、複数の値をテーブルの結合に格納する場合の扱い

- ORMでの、enumをステートオブジェクトとして利用する場合の扱い
    - enum型としてモデリングした場合の、永続化について。
    - 本書執筆時点では、enum型を上手く格納するORマッパーは存在しないので、ユーザー定義型などでテキスト表現を格納したりと、工夫が必要になってくる




### :question:疑問点
- P.239の「もちろんデータベースにおける参照整合性(外部キーなど)を考慮しなければいけないこともあるだろう〜（中略）〜それ専用に設計したデータモデルを使わせることになるだろう」というのは、データベース用のモデルクラスを個別で用意するという意味だろうか？　データベースのモデルクラスから、ドメインモデルに変換するのをリポジトリとかで対応する感じ？


### :memo:書記欄
- モデルから先に考える
    - そのあとに永続化することを考える
    - そっちの影響で、歪められることが無いように

---


## 6.7 まとめ
### :books:概要
- 値オブジェクトの特徴と、その利用方法を学んだ
- 値オブジェクトを活用して、結合時の複雑性を最小限に抑える方法を調べた
- ドメインの標準型を値で表現する方法を探り、それを実装する際の複数の戦略を学んだ
- SaaSOvationが、可能な限り値を使ってモデリングするようになった経験を見た
- SaaSOvationのプロジェクトを通して学んだ


### :question:疑問点
- 


### :memo:書記欄
-

---

## 輪読会感想ふりかえり用

## 読書会進め方ふりかえり用

## その他、メモとか用の領域


