## 10.1 コアドメインにおける集約の使用

### :books:概要

集約の観点からSaaSOvationのプロダクトを実装するプロセスを学ぶ。ここでは、次の要件を実現する

- プロダクトは、バックログアイテムやリリースそしてスプリントを持っている
- 新しいプロダクトバックログアイテムが計画される
- 新しいプロダクトリリースが計画される
- 新しいプロダクトスプリントが予定される
- 計画されたバックログアイテムが、リリースに向けて予定される
- 予定されたバックログアイテムは、スプリントにコミットできる

#### 第一の試み:巨大な集約

何も考慮せずにモデリングした場合、大きな集約ができ上がる。こうした大きい集約「プロダクト」を作成した場合、数千のバックログアイテム、スプリント、リリースオブジェクトを毎回メモリに読み込み、更新する必要があり、性能面で期待することはできない。

利点としてはモデリングは簡単である。しかし、実用に耐えられるものではない。このモデルでは、複数のユーザーが同時に操作した場合に、トランザクションが衝突する可能性が非常に高い。通常、エンティティの実装を行う場合、楽観的並行性制御と呼ばれる手法がよく用いられる。

| 排他制御方式 | 説明 |
|----|----|
| [楽観的並行性制御](https://ja.wikipedia.org/wiki/%E6%A5%BD%E8%A6%B3%E7%9A%84%E4%B8%A6%E8%A1%8C%E6%80%A7%E5%88%B6%E5%BE%A1) | 楽観的ロックの概念である。他の処理と競合してはならないトランザクションにおいて、開始時には特に排他処理など行なわず、完了する際に他からの更新がされたか否かを確認し、もし他から更新されてしまっていたら自らの更新処理を破棄し、エラーとする |
| [悲観的並行性制御](https://ja.wikipedia.org/wiki/%E6%82%B2%E8%A6%B3%E7%9A%84%E4%B8%A6%E8%A1%8C%E6%80%A7%E5%88%B6%E5%BE%A1) | 悲観的ロックの概念である。他の処理と競合してはならないトランザクションにおいて、開始時に更新の抑止がされていないことを確認後(抑止されている場合は解除されるまで待機するか、エラーとして処理をあきらめる)他からの更新を抑止し(排他制御)、完了する際に抑止情報を解除する |

楽観的並行性制御で実現した場合、エンティティがバージョン番号を保持しており、なんらかの変更を行う度にバージョン番号を加算させる。もし別のユーザーが集約を更新済みの場合、想定しているバージョン番号と異なるため、後から更新しようとしたユーザーがエラーになる。そのため別のユーザーに更新された後の最新値を取得して、更新処理をやり直す必要がある。

チームで作業をする製品の場合、楽観的並行性制御で実現したプログラムは実用に耐えられないことが多い

#### 第二の試み:複数の集約

Productとそれに関連する概念を別の集約としてモデリングする。ここでは、4つの集約を用意した。この4つの集約はProductIdによって関連付けされる。

このように分割することでソースコードのインターフェイスは次のように変化する

```cs
/// 大きな集約
public class Product
{
    public void planBacklogItem(
            String summary,
            String category,
            BacklogItemType type,
            StoryPoints storyPoints)
    {    }
    public void scheduleRelease(
            String name,
            String description,
            DateTime begins,
            DateTime ends)
    {    }
    public void scheduleSprint(
            String name,
            String goals,
            DateTime begins,
            DateTime ends)
    {    }
}
```

```cs
/// 複数の集約
public class Product
{
    public BacklogItems.BacklogItem PlanBacklogItem(
            BacklogItemId newBacklogItemId,
            String summary,
            String category,
            BacklogItemType type,
            StoryPoints storyPoints)
    {    }
    public Release ScheduleRelease(
            ReleaseId newReleaseId,
            String name,
            String description,
            DateTime begins,
            DateTime ends)
    {    }
    public Sprint ScheduleSprint(
            SprintId newSprintId,
            String name,
            String goals,
            DateTime begins,
            DateTime ends)
    {    }
}
```

- 各関数がファクトリの役割を果たすため、戻り値を持つようになる
    - インスタンスへの参照を返す
- 大きな集約がIDを管理していたが、外部から指定する必要が生じた

つまり、トランザクションを外部に追い出すことでトランザクションが失敗する問題を解決した

### :question:疑問点

- P.339の「Hibernateのマッピングでoptimistic-lockオプションをfalseにすれば、トランザクションの失敗がドミノ倒しのように連鎖することを回避できる」とあるが、https://docs.jboss.org/hibernate/orm/3.6/reference/ja-JP/html/transactions.html
の「13.3.4. 自動バージョニングのカスタマイズ」にあるように、ORMが自動でバージョニングを防ぎ、自前で集約の整合性を担保するような話ということで良いのか？


### :memo:書記欄

- これは自前で排他制御を実装するってことだと理解しました

---

## 10.2 ルール：真の不変条件を、整合性の境界内にモデリングする

### :books:概要

境界付けされたコンテキストないで集約を見つけ出す場合には、そのモデルの真の不変条件を理解しなければ、集約にどのオブジェクトを含めるべきか正しく判断できない

>不変条件   
>常に整合性を保っている必要があるビジネスルール

整合性の境界の論理的な意味は、「**その内部にあるあらゆるものは、どんな操作をするにかかわらず、特定の不変条件のルールに従う**」ことである。つまり、集約はトランザクション整合性の境界と同義になる。そのため、適切に設計された集約では、トランザクション内での不変条件の整合性を完全に維持することが出来る。

### :question:疑問点

- P.341から所々出てくる、「オブジェクトグラフ」というのは、E-R図的な解釈でOK？　http://www.spice-of-life.net/wiki/index.cgi/d/?wikiname=CDPGObjectGraphs


### :memo:書記欄

- http://koriym.github.io/print_o/v1/libs/bear.sunday.html

---

## 10.3 ルール：小さな集約を設計する

### :books:概要

大きな集約の問題を回避するために、小さい集約を複数作成する。これまでひとつだった集約を複数に分解する。各集約それぞれに集約ルートが存在するようになる。

大きな集約と小さな集約を比較すると次のようになる

| 項目 | 大きい集約 | 小さい集約 |
|----|----|----|
| トランザクションの衝突 | 多い | 少ない |
| 設計難易度 | 低 | 中 |
| スケーラビリティ・性能 | 低 | 高 |
| エンティティ間の依存 | 直接参照 | ID参照 |

集約を小さくすることでトランザクションが衝突しなくなる。ただし、要件を満たすだけの性能が出せるかは、実際のシナリオに基づいた検証を行う必要がある。

----

ここで、「**小さな集約**」のサイズについて考察する。取り得る最小の集約は、一意な識別子とそれ以外の属性を1つ持つものだが、これでは設計難易度が高まる。ここでは、**集約の構造を、ルートエンティとその他の最小限の属性だけにする**ことである。つまり、関係性が高く、整合性を同時に満たす必要がある属性のみにする。

小さめの集約はパフォーマンスやスケーラビリティにメリットがあるだけでなく、トランザクションも成功しやすくなる。楽観的並行性制御で実現したとしても、集約が保証する排他制御の期間が短くなるため、更新の衝突の可能性が低下する。

#### ユースケースを鵜呑みにしない

ユースケースが100%ドメインエキスパートとモデリングチームの視点を反映しているわけではない。個々のユースケースと今のモデルをつじつまを合わせる必要はあるが、モデルを不要に変更する必要はない。

### :question:疑問点

- P.342の図10-3の説明の後、「不変条件を見誤り、合成の利便性だけを見て設計を進めた」という記述があるが、そもそも合成とは？　その合成の利便性とは何か？

### :memo:書記欄

- 利便性はたくさん集めておけば情報が多い
- 一つの集約でまとめてロードされるので、ちまちまロードしたりしなくてすむので実装が楽、利用も楽。という感じ。セーブも同様。
- 関連をそのまま集約として設計してしまって結果として色々問題出ちゃったよー的なこれは集約設計あるある
- コンポジションは強い繋がりを示すので、不変条件に繋がっていると思います
- つい最近も似たケースで集約を分割したばっか店舗と予約履歴はライフサイクルを共にするので、一つの集約と想定してたけど稼働が進むほど予約履歴が膨大になって、店舗集約をリスト取ろうと思うと膨大なデータを全て合成したモデルを作らなくてはいけなくなってしまって。


---

## 10.4 ルール:他の集約への参照には、その識別子を利用する
### :books:概要

集約では、他の集約ルートへの参照を保持するようにする。密結合ではなく識別子(ID)を介した参照を使うことで、疎結合に集約を組み合わせる事ができる


集約の更新に対しては以下のポイントを押さえる

- 単一のトランザクションでは単一の集約のみ更新する
- 複数のインスタンスを単一のトランザクションで更新しようとしている場合、現状の整合性の境界を再考する
    - モデリングを見直すチャンス
    - ユビキタス言語で表現できていない項目が見つかる可能性が高い
- どうしても複数の集約を更新しなければいけない場合は、結果整合性を用いた対策を検討する
    - アトミックな整合性はここでは考慮しない

他の集約の参照をしないことが理想だが、他の集約の参照は必要になることが多い。

#### 識別子への参照を使って、複数の集約を一度に扱えるようにする

外部に集約への参照は、識別子のみを保持し、オブジェクトそのものの参照は保持しない。

外部参照が識別子のみになることでメモリ面で考慮する項目が減るため、インスタンスの作成が速くなる。また、識別子を使って連結をしているため、2つの集約間の依存関係が分断されること無く、連携し続けることが出来る。

#### スケーラビリティと分散

外部の集約への直接の参照をせずに、識別子の参照を用いることで、永続化の状態をより広範囲に持ち運べるようになる。つまり、スケーラビリティが無限になる。

また、単一のトランザクションの更新の責務が1つのインスタンスのみに限定されるため、処理の並列化が可能になる。つまり、分散処理が容易に実現できるようになる。そのため、この点からもスケーラビリティを向上させることが出来る。

### :question:疑問点

- P.348 なぜドメインサービスではなく、アプリケーションサービスで依存オブジェクトを先に詰め込むのか？　==> アプリケーションの都合で変な組み方をするから？
- 本の内容より、単純な疑問ですが、P.344の「ユースケースを鵜呑みにするな」という節のところで、ビジネスアナリストが考えるユースケースを考えるもの？　ドメインエキスパートが考えそうなものだけど…。
- P.348 『切り離されたドメインモデル』の詳細は記述されていないが、本当に無視していいのだろうか？
- P.348 「モデルのナビゲーション」の「私がお勧めするのは、 それとは別の方法」において 「ofTeam」を別の集約に渡して使用するのは、大丈夫なのか？backlogItem.assignTeamMemberToTaskでofTeamを変更できてしまわないか？

### :memo:書記欄

- ASにやらせたいのではなく、Domain内で外部集約の参照を持ちたくないという事ですね。
- Domain サービスも Domainオブジェクトですね。でも、それは考え方次第なので、それをありってしてしまう人もいますよ。端的に言えば、これってRepositoryをDomainオブジェクトにInject するかしないか論ですね。、ちなみに成瀬本はDomainServiceにRepositoryをInjectしてます。
- ユースケース自体は全員(ステークホルダー)が考えるものだと思っています
- AggregateにRepositoryをInjectするパターンも含めてでしょうね。
    - ちゃんとダメって書けよ。
- 逆に、エンティティがリポジトリをもたせたいという動機は何か
    - アプリケーション層とかからの利用が簡単になる。
    - 膨大な履歴の中で、Repositoryを使用して必要な部分だけを振る舞いの中で読んだ方がメモリに優しいとかですね。
- ofTeamという集約を渡したからといって、その中で変更していいわけではない。
- DomainServiceを使えよ。
- 消極的にやる
---

## 10.5 ルール:境界の外部では結果整合性を用いる
### :books:概要

これまでの考察の結果、複数の集約にまたがるビジネスルールがある場合には、結果整合性を使うことになる。この場合、メインとなる集約でイベントを発生させ、受信した側の集約にて処理を継続する。この流れによって結果整合性が実現する。ドメインイベントには、イベントで処理するべき内容が把握できるように識別子が含まれる。

このとき、結果整合性を実現するためには遅延が発生する。そのため、ドメインエキスパートにどの程度遅延が許容できるかをヒアリングし、要求を実現するようにする。

>設計者とドメインエキスパート間でこの遅延に関する考え方に差異があることが多い

ドメインのシナリオ中には、トランザクション整合性と結果整合性のどちらを使うべきか判断に迷うものがある。このときは次の指針に従う

- ユースケースを実行するユーザーが自分であれば「トランザクション整合性」を利用する
- 他のユーザーやシステムの役割と思える場合には「結果整合性」を使う

### :question:疑問点

- P.352の「誰の役割かを考える」で、トランザクション整合性か結果整合性かを判断する指針として、「ユースケースを実行するユーザ自身の役割ならば、トランザクション整合性。他のユーザやシステムの役割なら、結果整合性を受け入れよう」とあるが、これの具体的なイメージがついていない。特に、他のユーザやシステムが整合性を保つというパターンとはどういうものか？

### :memo:書記欄

- 常に同一ユーザが行なう一連の作業が強く整合していなければならないというわけではないし、複数のユーザで行なう一連の処理が結果的に整合していれば十分というわけでもないので、ここで述べられている指針は、大まかな指針であって、常に適用してよいものではない、と思うのだけど、どうでしょう?



---

## 10.6 ルールに違反する理由
### :books:概要

複数の集約のインスタンスへの変更をあえて、トランザクションをひとつにまとめる場合には次のものがある。

1. ユーザーインターフェースの利便性を優先
    - 画面の操作上、複数の集約をまとめて作成するようなシナリオを実現する
    - このとき、集約を一括で作って操作しても問題ない
2. 技術的な仕組みの不足
    - 集約を小さくすることが難しい
    - 結果整合性を実現するためのアーキテクチャが存在しない場合
    - イベントを扱うメッセージング基盤がない場合
3. グローバルトランザクションの強制
    - 既存のアーキテクチャ基盤や企業ポリシーに従う場合
        - 2フェーズコミットのようなグローバルトランザクションを使わなければいけない場合が該当
    - 極力複数の集約を更新しなくても問題ないように、トランザクションの衝突が発生しないようにする
4. クエリのパフォーマンス改善
    - 他の集約を参照する場合、識別子で参照せずに直接参照したほうが性能が良いケースがある
    - このような場合は直接参照します

ルールに違反する判断をする場合には注意する必要がある。長期的な目線で考えれば、ルールに従ったほうがプロジェクトにとってプラスになることが多い。

#### ユーザーインターフェースの利便性

使い勝手を考慮して、複数のものに共通する項目を設定した上での、一括作成が出来るようになっているユーザーインターフェースが該当する。共通するプロパティをユーザーインターフェース上の一つのセクションで入力させて、それ以外のプロパティを個別に入力させることで、無駄な繰り返しを排除する。

```cs
public class ProductBacklogItemService  {
    public void planBatchOfProductBacklogItems(
        String tenant_id, String product_id,
        BacklogItemDescription[] descriptions) {
        Product product = productRepository.productOfId(
                    new TenantId(tenant_id),
                    new product_id(product_id));

        for (BacklogItemDescription description in descriptions) {
            BacklogItem planned_backlog_item =
                product.planBacklogItem(
                    description.summary(),
                    description.category(),
                    BacklogItemType.valueOf(description.backlogItemType()),
                    StoryPoints.valueOf(description.storyPoints()));
            backlogItemRepository.add(planned_backlog_item);
        }
    }
}
```

不変条件の管理する上で問題がなければトランザクションをまとめることにメリットは大きい。

#### 技術的な仕組みの不足

結果整合性を利用するためには、何らかの形式で境界付けされたコンテキストを超えた処理が必要になる。境界を超える仕組みがない場合、巨大な集約に戻ってしまう。

また、ユーザーと集約の親和性も課題になる。単一のトランザクションで複数の集約を処理することは理にかなっている。また、並列処理行えば衝突は起こるものである。ただし、ユーザーと集約の親和性が確保されていれば衝突の確率は低くなる

#### グローバルトランザクションの強制

既存のアーキテクチャ基盤や企業ポリシーにより、2フェーズコミットのようなグローバルトランザクションを使わなければいけない場合がある。グローバルトランザクションは、システムのスケーラビリティが劣るため、できるだけ少ない集約で実現できるようにする

##### 2フェーズコミット

2フェーズコミットでは、トランザクションのコミット処理を2段階のフェーズにわけることによって原子性を保証する

1. 第一フェーズ:コミット要求フェーズ
   - コミットできる状態であるかどうかを確認するための準備する
   - コミット対象の関係者からOKの返信を待つ
2. 第二フェーズ:コミットフェーズ
   - 第一フェーズでOKをもらった相手に対してコミットを行う

#### クエリのパフォーマンス改善

他の集約を参照する場合、識別子で参照せずに直接参照したほうが性能が良いケースは直接参照する。ただし、集約の肥大化とパフォーマンスのトレードオフになるので注意が必要。

### :question:疑問点


### :memo:書記欄

---

## 10.7 発見による知見の獲得
### :books:概要

巨大な集約であったProductをリファクタリングで分割した。BacklogItemIdを使って一意性を担保しているため、全てのValueObjectから参照できるようになった。

ここからモデルを再検討する際にはユビキタス言語に従ってリファクタリングを実施する。例えば、不変条件としては以下の記述がある

- When progress is made on a backlog item task, the team member will estimate task hours remaining.
- When a team member estimates that zero hours are remaining on a specific task, the backlog item checks all tasks for any remaining hours. If no hours remain on any tasks, the backlog item status is automatically changed to done.
- When a team member estimates that one or more hours are remaining on a specific task and the backlog item's status is already done, the status is auto-matically regressed.

これから次の条件が明確になった

- バックログアイテムの状態は自動で設定される
- バックログアイテムの状態はタスクの残作業時間の総計に依存する

ここで新しくモデルを考察する際には次の点に注意する

- 不変条件を満たすことが出来るモデルであるか
- 構成のパフォーマンスとスケーラビリティ

#### 集約のコストの見積もり

Taskは EstimationLogEntityのインスタンスのコレクションを保持している。これによってチームメンバーが見積もりをした時間が管理される。

次のような視点でタスクを管理する

- スプリントの期間
    - 10日間
    - 1つのタスクの最大値を10時間にする
        - 一日1時間づつ実施する
        - 毎日バックログリファインメントを実施すれば、10回見直すタイミングがある
- 機能ごとにタクスを作成する
    - ヘキサゴナルアーキテクチャやレイヤードアーキテクチャのフィーチャースライス単位
    - フィーチャースライス単位で2～3件のタスクが必要になるとする
        - ユーザーインターフェースレイヤ:3件
        - アプリケーションレイヤ:2件
        - ドメインレイヤ:3件
        - インフラストラクチャレイヤ:2件
    - 合計タスクが10件のため、バックログアイテムとして入れることが出来る

スプリントの期間Xバックログアイテムの最大値、つまり、100件のオブジェクトが管理できればいい。

#### 一般的な利用シナリオ

ここで重要なポイントは、「**一般的な利用シナリオを検討すること**」である。検討するシナリオが具体的にあることで設計が推進する。

シナリオがあることで分析は深くなり、プロダクトに対する理解が深まる。この分析は、タスク分割が細かくなっても、人員増加によってベロシティが増えても変わらない。

#### メモリの消費

保持が必要なバリューオブジェクトの容量について分析する

- デイリーで値オブジェクトを保持する
    - 同じ日に何度も見積もりを行われた場合は上書き
    - その日の最後に記録する
- 一日のうちの発生した記入ミスは記録しない

これを前提に使用するメモリ容量を算出する。要求が変わり、ミスをした分も記録する場合、どの程度更新がかかるかを予測し、増分を算出する。

そして、全体のメモリ量を使ってパフォーマンスを見積もる。保存にかかる時間やクエリを使った検索、特定のタスクを読み出すときの遅延などを見積もる。

ここで重要なポイントは、**具体的な数値を使って見積もること**である。要件に基づいて数値を算出することで具体的に話をすることができ、判断をする材料を集めることが出来る

>このときに不確定要素が多く判断ができない場合でも、別の設計を検討する際の足がかりとなる情報が何かが明確になる

#### 別の設計手法の検討

前のモデルからTask個別に管理する設計をしたときのメリットを分析する

- 集約を構成するオブジェクトの数を減らせる
    - Taskが10時間分の10個
    - BacklogItemが10日分の10個
- 管理するオブジェクトの数が少なくなったため、遅延読み込みのオーバーヘッドが減る

メリットがあることがわかったので、このモデルを成立させるための要件分析を行う

- 複数の集約(BacklogItemとTask)を同一のトランザクション内で更新しないこと
- バックログアイテムの状態の自動更新を、受け入れ可能な時間内で行えるかどうか判断する
    - 不変条件の整合性が弱まる
        - バックログアイテムの状態と、トランザクションの整合性を保てない
    - 残作業時間がゼロになってから状態が完了になるまでの遅延は受け入れ可能

#### 整合性の実装

分離させた集約を実装する

```cs
public class TaskHoursRemainingEstimated : DomainEvent {
    private Date occurred_on_;
    private TenantId tenant_id_;
    private BacklogItemId backlog_item_id_;
    private TaskId task_id_;
    private int hours_remaining_;
}
```

このイベント専用のサブスクライバがイベントを待ち受け、そのイベントをドメインサービスに委譲し、整合性を保つ処理を行う。

- BacklogItemRepositoryを使って、指定したBacklogItemを取得する
- TaskRepositoryを使って、そのBacklogItemに関連する全てのTaskインスタンスを取得する
- BacklogItemのestimateTaskHoursRemaining()コマンドを実行する
    - ドメインイベントのhoursRemainingを取得する
    - 関連するTaskインスタンスを取得する
    - BacklogItemはパラメータの内容に合わせて、自身の状態を更新する

この処理を最適化することを検討する。

- 結果整合性を担保し、ビューを最新状態にすることを諦める
- ビューのバックグラウンドでポーリングをして、最新状態で更新する
- ビュー上に現在の状態が最新状態かどうかを示す合図を表示する

処理不可やユーザーが受け入れ可能な性能を考慮して選択する解決策を検討する

#### それはチームメンバーの仕事なのか?

「**それはチームメンバーの仕事なのか?**」と問い合わせることで、ドメインに関する重要な知見が得られることが多い。つまり、自分の仕事の範囲と他ドメインの仕事の範囲が明確になる。

必要十分な処理を行うことで、処理の最適化を行うことが出来るようになる。

#### 決断の時

分析を行っているだけでは先には進めない、実際に実装することでわかることもあるので、ある程度分析を行ったら実装に取り掛かる。

ここでは、**特別なユースケース定義を使って計画を立てること**が重要なポイントである。そうすることで、手早く結論を得ることができ、方針がブレることがない。

### :question:疑問点
- P.358 ひとつのタスクを12時間として、12日間で1日1時間ずつ　という試算をしているが、なぜこの計算なのだろう・・？ さらに12時間を1時間ずつに割ったので、タスク当たり12回の再見積もりがある、とのことだがよく意味が分からない:crying_cat_face: 

- P.360 そもそもメモリの消費を気にするなら DDD で作らない気がするけど、どうなんだろう。
- P.362 結果整合性の実装のタイミングで最適化をしようとしているが、もっと前にできないのだろうか？ 何かいい方法とか指針を知っている方がいらっしゃれば聞いてみたいです。
- 
### :memo:書記欄

- P.358 ひとつのタスクを12時間として、12日間で1日1時間ずつ　という試算をしているが、なぜこの計算なのだろう・・？ さらに12時間を1時間ずつに割ったので、タスク当たり12回の再見積もりがある、とのことだがよく意味が分からない:crying_cat_face: 
    - そういう例だと思われる
    - 1ｈでも2hでも良くて
    - 仮に、1hとか。気分とか。
- P.360 そもそもメモリの消費を気にするなら DDD で作らない気がするけど、どうなんだろう。
    - 検討項目の1つという位置づけです
    - でも、たしかにメモリの消費をコントロールできるのは集約だけだから大切っちゃ大切
    - 大事じゃないけど「あとで問題出たら考える」とかでないと、ドメイン歪むよ？（極論ではあるが
    - 検討は必要だと言ってるのかと
    - 学問(研究)と製品は違うよ
    - この抽象レベルで重要なのは、メモリ使用量よりも、大きな集約が必要以上に広い範囲のオブジェクトを抱え込んで、一貫性保証の粒度が大きくなって競合しやすくなるとか、そういう方をまず検討してからかなー。
    - CPU計算量も、ストレージ量も、だな。これらが破綻してればそもそも解決方法が現実的ではないという判断が必要。
    - あー、そこの文脈ならわかりますね。「メモリの事を考えて」が主にはこない。
    - たしかに、メモリよりも先に整合性の問題が出ますよね
    - 集約設計にも大きくかかわってきますね。非現実的なコレクションを毎回ロードする必要がある集約を作ってしまう訳にはいかないので。
    - 直観的に過剰にメモリを食い過ぎるならまず分割を考えるけれど、そうでないなら主問題にはしないなー。ゆがむので。
    - そうそう「超巨大ツリー」や「万件メモリに貯める」は、「なんか機能の切り方（ユースケース）これでいいんかな？」が先に来る…かも。(そんなに深い言葉じゃないよ表層的やけどw)
    - 使用メモリの許容範囲ってのは時代ごとに全然違いますからね

- P.362 結果整合性の実装のタイミングで最適化をしようとしているが、もっと前にできないのだろうか？ 何かいい方法とか指針を知っている方がいらっしゃれば聞いてみたいです。
    - モデル構築の段階で「最適化」をするのは YAGNI。モデル構築の段階で考えるべきは、正しさ。
    - これは「最適化」というより、「どうつじつまが合っているように見せるか/ごまかすか」という話だよなー。
    - DBのくだりも結論ではないかだろう （あくまで手法）
    - 妥協というか、実装方法の工夫だと思う。

---

## 10.8 実装
### :books:概要

実装では、ドメイン駆動設計で使用する、エンティティ・値オブジェクト・ドメインイベント・モジュール・ファクトリ・リポジトリについて吟味し、これらを組み合わせて実現する

#### ルートエンティと一意な識別子の作成

集約を作る場合、外部からの操作を担うひとつのエンティティを集約ルートとして選択する。ここでは、ルートエンティティである「[product](https://github.com/VaughnVernon/IDDD_Samples_NET/blob/90fcc52d9c1af29640ec2a8a3e0e7c692f3e6663/iddd_agilepm/Domain.Model/Products/BacklogItems/BacklogItem.cs)」クラス以下に示す。

```cs
// 集約ルート(ルートエンティティ)「バックログアイテム」
public class BacklogItem : EntityWithCompositeId
{
    // コンストラクタ
    public BacklogItem(
            TenantId tenantId, ProductId productId,
            BacklogItemId backlogItemId, string summary,
            string category, BacklogItemType type,
            BacklogItemStatus backlogItemStatus,
            StoryPoints storyPoints)
        {
            this.BacklogItemId = backlogItemId;
            this.Category = category;
            this.ProductId = productId;
            this.Status = backlogItemStatus;
            this.StoryPoints = storyPoints;
            this.Summary = summary;
            this.TenantId = tenantId;
            this.Type = type;

            this.tasks = new List<Task>();
        }

    // 自分の一意な識別子(値オブジェクト)
    public BacklogItemId BacklogItemId { get; private set; }

    // 他集約「テナント」の一意な識別子(値オブジェクト)
    public TenantId TenantId { get; private set; }

    // 他集約「プロダクト」一意な識別子(値オブジェクト)
    public ProductId ProductId { get; private set; }

    // 「タスク」群の参照(エンティティ)
    readonly List<Task> tasks;

    // 自分のプロパティ「バックログアイテムタイプ」(値オブジェクト)
    public BacklogItemType Type { get; private set; }

    // 自分のプロパティ「バックログアイテムステータス」(値オブジェクト)
    public BacklogItemStatus Status { get; private set; }

    // 自分のプロパティ「カテゴリー」
    public string Category { get; private set; }
}
```

集約ルートはエンティティなので、そのエンティティを判別するための一意な識別子を持たなければならない。ここでは「ProductId」を識別子とする。

#### パーツは値オブジェクトにする

集約の属性としては値オブジェクトを使うことが推奨されている。エンティティにするか値オブジェクトにするかを悩んだ場合、後々の交換が大変でなければ「値オブジェクト」を選択する。

>ただし、HibernateやEntity FrameworkといったO/Rマッピングツールの相性上、エンティティが望ましい場合はエンティティを選択してもいい

エンティティと値オブジェクトで何を使っているか整理し、出来るだけ値オブジェクトにする。

将来RDBMSからキーバリューストアに移行することになったとしても、エンティティから値オブジェクトに変更することはそれほど難しくない(MongoDBのようなドキュメント指向データベース等では、集約自体をシリアライズしてひとつの値として格納する)。

また、集約に入れたオブジェクトは他の集約で使ってはいけないという制約はない。集約の内部に実装するエンティティも値オブジェクトも、他の集約から参照して問題はない。

#### デルメルの法則、そして「命じろ、たずねるな」を意識する

集約を実装するときに使える原則としてデルメルの法則と「命じろ、たずねるな」がある。両方とも情報隠蔽を重視した原則である。

- デルメルの原則
    - **最小知識の原則**
    - クライアントがサーバーの情報を使うときの指針
    - 必要以上にサーバーの構造に関して知ってはいけない
    - 公開されているインターフェイスのみを使用する
        - 内部のパーツに適切に処理を委譲する
- 「命じろ、たずねるな」
    - オブジェクトは何をするべきか教わるべきである
    - クライアントがサーバーの内部状態を取得してから判断し、サーバーに処理を依頼してはいけない
    - クライアントからサーバーには「命じる」ことしかしてはいけない
        - 処理を受け付けるかどうかはサーバーが判断する
    - 命令は公開されているインターフェイスを介して実行する

この原則に従った関数を以下に示す。

```cs
public class Product : Entity, IEquatable<Product>
{
    public void ReorderFrom(BacklogItemId id, int ordering)
    {
        foreach (var productBacklogItem in this.backlogItems)
        {
            productBacklogItem.ReorderFrom(id, ordering);
        }
    }

    public ICollection<ProductBacklogItem> AllBacklogItems()
    {
        return new ReadOnlyCollection<ProductBacklogItem>(new List<ProductBacklogItem>(this.backlogItems));
    }
}
```

ReorderFrom()関数内部で必要な処理を実行している。クライアント側はサーバーの内部状態を知らない。サーバーの内部状態を変更する関数はprivate/protected関数で実装されているため、クライアントからは操作することが出来ない。そのため、公開されているインターフェイスを介してサーバーに処理を命令(委譲)している。

##### デルメルの法則

>デメテルの法則:最小知識の法則
>基本的な考え方は、任意のオブジェクトが自分以外（サブコンポーネント含む）の構造やプロパティに対して持っている仮定を最小限にすべきである

デメテルの法則は、最小知識の原則とも呼ばれ、オブジェクトのメンバーの「プロパティやメソッド」を直接触らない法則である。例えば、あるオブジェクトが存在する場合、呼び出していいのは以下の4つである。

1. オブジェクト自身のメソッド
2. 自身にパラメータとして渡されたオブジェクトXのメソッド
3. 自身の内部でインスタンス化されたオブジェクトYのメソッド
4. 自身が保持しており、直接アクセスできるオブジェクトZのメソッド

逆に呼び出してはいけないものは、オブジェクトX／Y／Zのメソッドが戻したオブジェクトのメソッドである。

この法則に従う場合、オブジェクトが他の構造に依存しにくいため、保守性が向上する。デメテルの法則は、集約ルートに対して命令を出すが、集約の内部のエンティティや値オブジェクトに対して命令を出さないことを表している。

```cs
// デメテルの法則に違反している
console.WriteLine(student.class.grade)

// デメテルの法則に違反している
console.WriteLine(student.GetGrade().Method())

// デメテルの法則に違反していない
console.WriteLine(student.GetGrade())
```

##### 命じろ、たずねるな

>命じろ、たずねるな:Tell-Don't-Ask   
>オブジェクトを操作する際に、そのオブジェクトの内部状態をたずねることなく、命令だけするという指針

呼び出し先のオブジェクトの状態をたずねるという行動は、呼び出し側が知る必要のない情報を考慮する必要があることになるため、あまり望ましくない。

オブジェクトの状態をたずねると対象のオブジェクトに対する問い合わせが多くなる。命じることで問い合わせをへらすことが出来る。

```cs
class AskMonitor{
    private int value;
    private int limit;
    private boolean isTooHigh;
    private String name;
    private Alarm alarm;

    public AskMonitor (String name, int limit, Alarm alarm) {
        this.name = name;
        this.limit = limit;
        this.alarm = alarm;
    }

    public int getValue() {return value;}
    public void setValue(int arg) {value = arg;}
    public int getLimit() {return limit;}
    public String getName() {return name;}
    public Alarm getAlarm() {return alarm;}
}
```

AskMonitorクラスがデータコンテナとして振る舞うため、このオブジェクトへのアクセスが多くなる。また、状態の設定を外部に処理させている

```cs
AskMonitor am = new AskMonitor("Time Vortex Hocus", 2, alarm);
am.setValue(3);
if (am.getValue() > am.getLimit())
    am.getAlarm().warn(am.getName() + " too high");
```

これではオブジェクトへのアクセスが増えるだけでなく、オブジェクト一貫性も保つことが出来ない。そこで、命じるという処理を実装する

```cs
class TellMonitor{
    private int value;
    private int limit;
    private boolean isTooHigh;
    private String name;
    private Alarm alarm;

    public AskMonitor (String name, int limit, Alarm alarm) {
        this.name = name;
        this.limit = limit;
        this.alarm = alarm;
    }

    public int getValue() {return value;}
    public void setValue(int arg) {
        value = arg;
        if (value > limit)
            alarm.warn(name + " too high");
    }
    public String getName() {return name;}
    public Alarm getAlarm() {return alarm;}
}
```

これで内部状態を公開する処理が減り、オブジェクトの一貫性をクラス自身が担保できるようになっている

#### 楽観的並行性

要件分析を行い、あまり発生しない状況に関する対応をしないという方針をすることがある。対応しないデメリットと対応しない際の影響範囲を分析し、問題が限定されるのであれば対応しないという方針を決定する

集約全体を一つの値として永続化し、値自身が並行処理の衝突を回避出来るようになっている場合、並行処理の衝突について考察する必要はない。ルートが常に単一のオブジェクトになり、並行処理の衝突を検知できる。

#### 依存性の注入を避ける

別の集約を識別子で参照する場合、参照先の集約はそのままでは読み込まれない。参照先の集約の情報を永続化層から読み出す場合、次の2つの方式が存在する。

1. 集約の中からリポジトリを呼び出す方式
   - 「**切り離されたドメインモデル**」という遅延読み込み方法
   - 集約の内部からリポジトリやドメインサービスを使用するため、ドメイン層の中で永続層を意識する必要がある
2. 集約の外(リポジトリまたはドメインサービス)から、事前に呼び出しておく方式
   - 依存する集約を事前に準備した後で、メイン集約の処理に渡す方法
   - 依存するオブジェクトを事前に取得して、集約のコマンドメソッドの引数に渡す


### :question:疑問点
- P.370 `protected` だから『クライアント』からは見えないと記述されているが、いつから dll や jar 、またはコードベースなどを共有する前提の話だったのだろうか・・・？
- P.373の依存性の注入を避ける、というところの「リポジトリやドメインサービスを集約に差し込むことは一般的に好ましくないと考えている」とあるが、集約のコマンドメソッドにそれを渡すことも、好ましくないように思えるけど、どうだろう


### :memo:書記欄

- P.370 `protected` だから『クライアント』からは見えないと記述されているが、いつから dll や jar 、またはコードベースなどを共有する前提の話だったのだろうか・・・？
    - クライアント はそれじゃないかも。クライアントコードでは
    - ざっくり言えば「呼び出し元」
    - 結構カタカナ言葉はそういう日本語での意味が広いから、ユビキタス言語を作るときに避ける
    - ﾕ　ｰ　ｽ　ｹ　ｰ　ｽ
      利用者毎業務経緯実行反映登録業務!!!!!
- P.373の依存性の注入を避ける、というところの「リポジトリやドメインサービスを集約に差し込むことは一般的に好ましくないと考えている」とあるが、集約のコマンドメソッドにそれを渡すことも、好ましくないように思えるけど、どうだろう     
    - リポジトリを渡して、メソッド内で検索をするのではなく、「事前に探しておいて」←先にリポジトリで取得しておいてメソッドに渡しましょうって事ですね。
---

## 10.9 まとめ
### :books:概要


### :question:疑問点
- hibernate にべったりすぎて分かるけど分からない状態なのどうすればいいのか


### :memo:書記欄

- hibernate にべったりすぎて分かるけど分からない状態なのどうすればいいのか
    - とりあえず、hibernateの便利機能を、抽出して考えておくとよさそう。

---


## 輪読会感想ふりかえり用

## 読書会進め方ふりかえり用

## その他、メモとか用の領域


