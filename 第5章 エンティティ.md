## 5.1 なぜエンティティを使うのか

### :books:概要

- ドメインの概念をエンティティとして設計するのは、その同一性を気にかけるときだ。(P.163)
  つまり、システム内の他のオブジェクトとの区別が必須の制約となっているときである。

- エンティティには **一意な識別子** があって、**変化する** という特性がある。(P.164)
  これが6章の値オブジェクト(Value Object) と異なる点だ。 
  ※ 値オブジェクトに識別子はなく、値が同じなら同一。また一度作ったら不変。
  
- 値オブジェクトとしてモデリングすべき概念を、エンティティとしてしまうような誤用が想像以上に多い。(P.164)
  この考え方に同意できないなら、DDD が業務のニーズに合わないかもしれない。
  CRUD ベースのシステムのほうがしっくりくるのではないか。

  ただしDB の編集機能の開発のような場合、CRUD ベースだと無駄な手間になってしまう。
  CRUD で十分なら Groovy と Grails、あるいは Ruby on Rails などを使うのが最適だろう。
  

### :question:疑問点
-

### :memo:書記欄
-

---

## 5.2 一意な識別子
### :books:概要

- エンティティを一意に識別するための属性や振る舞いのこと。(P.165)
    - つまり『一意なキー』となる情報。
    - エンティティの問い合わせにも使える。

- キーとして使えるかどうかに大きく関わってくるのが、人間にとっての可読性である。(P.165)
    - ユーザーの姓名を検索する機能があるなら、姓名を Person エンティティの一意な識別子とすることはまずない(同姓同名があり得るので困る)。
    - 政府が発行する『納税者ID』なら、Company エンティティの一意な識別子として使える。
    - 値オブジェクトは不変なので、一意な識別子の受け皿として使える。

- 識別子の作成方法にはいくつかの種類がある。(P.166)

    - |         識別子の作成方法                   |                 具体的な例                                |
      | --------------------------------------- | ------------------------------------------------------- | 
      | ユーザーが識別子を指定する (P.166)           | ユーザーが入力したユーザーアカウント名やフォーラム名など |
      | アプリケーションが識別子を生成する (P.167)    | プログラム中で生成した UUID や GUID、時刻や乱数など |
      | 永続化メカニズムが識別子を生成する (P.170)    | DB への Insert 時に自動生成したり、Hibernate などが自動で生成したもの|
      | 別の境界付けられたコンテキストが定めた一意な識別子を、ユーザーが入力する (P.174)| ユーザーが紐付けたいプロダクトIDを入力するなど|


- 識別子の生成のタイミングは二種類ある(P.175)
    - オブジェクトの生成時に行う「早期生成」
    - 永続化の際に行う「遅延生成」

- 代理識別子(P.177)
    - ORMツールの中には、Hibernateのようにオブジェクトの識別子を自分たちの流儀で管理したがるものもある
        - [Hibernate \- Wikipedia](https://ja.wikipedia.org/wiki/Hibernate)
    - これをなんとかするために、ドメインモデル用の識別子とは別に、ORM用の識別子を持つ　→　代理識別子
    - 代理識別子用の外部から見える内容にしておくとよい。セーフガードとして扱えるのが、「レイヤスーパータイプ」である（P.178)
        - ソースコードの例として、「IdentifiedDomainObject」という抽象クラスを定義している
        - ドメインの識別子は、必ずしもデータベースの主キーでなくても構わない。
          代理識別子としてのidをデータベースの主キーにしておけば、Hibernate(ORM)をうまく利用ができる(P.179)
        - エンティティを Hibernate が使う主キーに汚染されたくないので、
          Hibernate の主キーを private で隠しておいて DB と結びつけ、永続化に使う。
          エンティティとしての主キーは別に持たせ(例だと`id`)、protected として継承先から見えるようにしている。

- 識別子の不変性(P.179)
    - ほとんどの場合、一意な識別子は一度定めたら変更してはいけないものであり、そのエンティティが生きている間はずっと同じであるべき
    - 識別子の変更を防ぐための簡単な対策としては、セッターをクライアントから見えなくする（=private)こと
    - さらにセッターの中で、一度入力が済んでいる場合は、変更を受け付けないように対策をすることもできる


### :question:疑問点
- "RDBをを使った場合の副作用のひとつは、ドメインモデルの知識がデータベースに流出してしまうことだ(P166)"とは具体的にどういうことでしょうか
- レイヤスーパータイプというのを、ネットでざっくり調べた限りだけど、Domain層用として、1つのスーパークラスを定義しておき、privateな代理識別子フィールドをもたせ、protectedなGetter/Setterを用意するということかな？
- ドメインモデルの識別子をそのまま永続化（DBなど）の識別子として扱えばいいのかと思っていたけど、必ずしもそうとは限らない？　そういう例ってどこかにある？


### :memo:書記欄
- 大前提としてここまでの工程で、ユビキタス言語やらを使ってドメインモデルを洗い出してます。

- そして、この戦術的な部分はそのモデルをシステムに落としこむ為の手法です。

- なので、ドメインモデルをドメイン層のオブジェクトに落としこみたいというのがモチベーションです。

- そんななか中このルールだけはDBのこの機能を使用して実現しています、みたいのが入ると、ドメインエキスパートは共に作成したモデル以外にも様々な資料を通じてしかシステムの中身を知る方法がなくなってしまいますね。

- レイヤスーパータイプというのを、ネットでざっくり調べた限りだけど、Domain層用として、1つのスーパークラスを定義しておき、privateな代理識別子フィールドをもたせ、protectedなGetter/Setterを用意するということかな？
    - ほかにもvalidation() の振る舞いとかをレイヤスーパータイプに持たせる、とかにも使ってます。
    - ドメイン層に限らないです。共通の振る舞いを複数のクラスに持たせたい、というときに使うパターンぽいです。

- ドメインモデルの識別子をそのまま永続化（DBなど）の識別子として扱えばいいのかと思っていたけど、必ずしもそうとは限らない？　そういう例ってどこかにある？
    - 代理キーにしてたとしても、ユーザアイデンティブファイア型とかにして、そのままドメインに持ち込んでますね。
    - その辺は自由ですね。


---

## 5.3 エンティティおよびその特性の発見

### :books:概要

#### ※ ひとまず超絶概要だけ記載しておきます。

SaaSOvation のチームは、ドメインに関する認識をユースケースやユーザーストーリー未満でまとめた。
そして『ユーザー』や『変更』、『認証済み』といった言葉に着目した。

変更という言葉が使われていれば、何らかのエンティティを扱っている。
複数のエンティティがある場合は、それらの関係性や包含関係などを注視して議論を進める。

- こうして議論とモデリングを繰り返して検討を進めていき・・・
  - エンティティとプロパティを発見し (P.182)、
  - 基本的な振る舞いの探求を行い (P.187)、
  - ロールと責務や、複数のロールを演じるドメインオブジェクトを見出し (P.192)、
  - エンティティのインスタンスを作成する方法を考え (P.197)、
  - 属性／プロパティのバリデーションについて考え (P.200)、
  - オブジェクト全体のバリデーションを検討し (P.203)、
  - 変更の追跡まで思索した (P.208)。



#### ※ ↑ の具体的な内容を書いてみる。

- エンティティとプロパティの発見(P.182)
    - 複数のエンティティを組み合わせて扱うこともある。
        - これらのエンティティは異なる集約のルートである。
    - 複数のエンティティで、同一の識別子(キー) を持ってもよい(図5-6)。
    - 複数の属性をまとめて、一つの識別子としてもよい。

- 基本的な振る舞いの探求(P.187)
    - `private boolean active` というメソッドはコードの意図を明確に示していない。 
    - `setActive(boolean)` というセッターを作ったが、public なセッターを使うと微妙だ。
    - ドメインエキスパートの言葉に従い `void active()`, `void deactive()` を使うことにした。
        - 例のソース(P.188) は、**意図の明白なインターフェース** になっている。
            - ※ 分かりやすいクラス名やメソッド名、引数などを使うことで意図が明白になっていること。

- ロールと責務(P.192)
    - 認証・アクセスコンテキストで使う『ロール』と、この章で使う『ロール』はまったく異なる。

- 複数のロールを演じるドメインオブジェクト(P.192)
    - オブジェクト指向プログラミングでは、一般的に、インターフェースがその実装クラスのロールを定める。
    - 複数のオブジェクトに共通する特性については、ひとつのオブジェクトに対して複数のインターフェースを混ぜ込むことで対応できる。
        - 実装するインターフェースの数が増える場合、複数のインターフェースを実装したクラスを作って、そのクラスを継承すると少しシンプルになる。
    - しかし移譲の方法によっては、**オブジェクト統合失調症** に悩まされることになる。
        - 「移譲は、設計を複雑にではなく簡単にする場合にのみ選択すべき技術」である。
    - **きめ細やかなロールのインターフェース** を使うと状況が改善するかもしれない。
        - `IAddOrdersToCustomer`
        - `IMakeCustomerPreferred`
        - これらのインターフェースのインスタンスを受け取って使うようにすれば、
          実装を他のクラスに移譲する必要がなくなるため、オブジェクト統合失調症の恐れがなくなる。
    - インターフェースを活用すれば、実装の詳細を隠蔽できる。

- 作成 (P.197)
    - エンティティのインスタンスを作るときには、パラメータ付きのコンストラクタを使って、エンティティを一意に識別できるようにする。
    - これらのパラメータはすべて `非null` とする。
    - パラメータを自己カプセル化するとよい。
        - コンストラクタで受け取ったパラメータを、自身の setHoge() を呼び、その中で null チェックを行う。
    - 複雑なエンティティのインスタンス化には、ファクトリが使える。

- 属性／プロパティのバリデーション (P.200)
    - エンティティで、単一の属性あるいはプロパティに不適切な値が設定されないようにするには、自己カプセル化を推奨する。
    - 自己カプセル化を使った保護は、バリデーションというより、契約による設計(いわゆるコントラクト) における **アサーション** だ。
    - 自己カプセル化したメソッド(例:`setHoge()`) の先頭で、正しくない値の場合は Exception を発火する。
        - Java なら `IlligalArgumentException`
        - C# なら `ArgumentException` や `ArgumentNullException`
    - ディフェンシブプログラミングとも呼ばれる。
    
- オブジェクト全体のバリデーション (P.203)
    - エンティティの個々の属性やプロパティは正しい状態でも、エンティティ全体として見ると正しくない場合がある。
    - こうしたオブジェクト全体のバリデーションに有効なのが、**遅延バリデーション** である。 
    - バリデーションに際しては、エンティティ全体を扱える必要がある。
      このためエンティティにバリデーションのロジックを入れてしまいたくなるが、
      バリデーションクラスとしてエンティティとは分離したほうがよい。
        - バリデーションのほうが、ドメインオブジェクトそのものよりも変更の頻度が高いから。
        - エンティティの責務が増えすぎるから。ドメインの振る舞いに加えて、その状態の維持という責務はやりすぎ。
    - バリデーションオブジェクトは、エンティティと同じモジュール(パッケージ、名前空間) に配置する。
    - バリデーションで無効な状態を発見したら、クライアントや結果の記録などの仕組みに通知するなどで、後々エラー原因を見直せるように出来る。
        - 重要なのは、すべての結果を集約すること。
        - トラブルを検出したらその場で例外を投げて終了してはいけない。
        - ※ コード例の単語は言葉遊びっぽい。無駄に分かりづらい👿
            - `Warble` = さえずる、歌う
            - `Wacky` = 奇抜な、いかれた
            - `Warped` = ゆがんだ

- オブジェクトの合成のバリデーション(P.207)
    - 複雑なバリデーションが必要な場面では、遅延バリデーションを使用すれば良い。
        - 複数のエンティティの組み合わせが全体として妥当であるかどうかを考える。
        - 複数のバリデータを使えばよい。
    - 一連のバリデーションをドメインサービスで管理できれば最高。
    - バリデーションが可能な状態であるかどうかを常に気にする必要がある。
        - 例えばドメインイベントを使って、バリデート可能であることを通知する。
    - このへん、著者のソースコードを追うといいかもしれません
        - [VaughnVernon/IDDD\_Samples](https://github.com/VaughnVernon/IDDD_Samples)

- 変更の追跡(P.208)
    - エンティティは変更され得るが、そのあらゆる変更を追跡することは必須ではない。
    - 追跡したいときは、イベントソーシングを利用する。


### :question:疑問点
- P197の不変条件は集約の関心ごとではあるが〜とある。集約は変更の整合性を集約内で保つためだと思っていたが、それだけではない？ 
- P183の「鍵となる用語は認証済みで、これは、何らかの形式の検索機能を用意する必要がある」というところで、なぜ検索機能が必要であるかがよくわからなかった。認証済み状態のユーザを検索する必要があるよ、という意味か？
- 遅延バリデーションのがどういうことか、よくわかっていない :+1: :+1: 
    - これか（Deferred Validation）
        - https://c2.com/ppr/checks.html
    
### :memo:書記欄
- 遅延バリデーションのがどういうことか、よくわかっていない :+1: :+1: 
    - エンティティ全体の整合性を担保したい。
        でもエンティティは変わっていくので、整合性をチェックしたい(チェックできる)タイミングまでバリデーションを遅らせる = 遅延バリデーション　というイメージ。
        値としては正常だけど、その値をエンティティとしてまとめたらNGだった、という感じ。じゃあ遅らせるしかない。
        - 私もkobayashi さんみたいな理解ですね。一時的にオブジェクトが契約を満たしていない状態を許容するだと思ってました


- P183の「鍵となる用語は認証済みで、これは、何らかの形式の検索機能を用意する必要がある」というところで、なぜ検索機能が必要であるかがよくわからなかった。認証済み状態のユーザを検索する必要があるよ、という意味か？
    - 認証された状態のユーザーが、わからないと処理できないよね
    - 単に識別子が必要って後ろの文章に繋げたかっただけだと。

- はい。集約はその集約内の整合性を保つ=不変条件も含まれます
    - 

---

## 5.4 まとめ
### :books:概要
- 
### :question:疑問点
- 素朴な疑問としては「みんな、ドメイン層組むとき、継承使ってんのか」すね


### :memo:書記欄
-

---


## 輪読会感想ふりかえり用
- バリデーションの種類ごとの実装手段の話は参考になりました。
- 結構流し読みしてしまった
- 抽象的なとこに具体性（ただし日本語がわかりにくい）をくれたので、個人的には参考になりました。
- 割と普通のことでも結構パターン名が書いてあるところに遭遇する
- 思えば似たような話で、前にこれもパターン名あったのかぁって思った事があったのに、忘れてしまって、かつ、どこでそれを見かけたのかも思い出せずにずっと気持ち悪い思いをしてます

## 読書会進め方ふりかえり用
- 質問を出しやすいアイデアが欲しい
- 文章を貼って、ここわかんね、という話でもOKにするとか。

## その他、メモとか用の領域


