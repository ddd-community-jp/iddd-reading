## 12.1 コレクション指向のリポジトリ

### :books:概要

- リポジトリには2種類ある
    - コレクション指向のリポジトリ
    - 永続指向のリポジトリ

- この設計は、コレクションを真似たものであり、少なくともコレクションの標準的なインターフェースはすべてシミュレートをする
- コレクション指向の設計がうまく機能するであろうヴァーノンが考える条件について、取り上げていく
    - リポジトリはSetの挙動を真似る必要がある。裏側の実装にどんな永続化メカニズムを使っていようが、同じオブジェクトを複数追加できるようにしてはいけない。また、リポジトリから取得したオブジェクトを変更したときに、それをリポジトリに「書き戻す」必要がないようにしなければならない。
    - HashSetの特徴を兼ね備えた永続データストアを作るのが目標である

- 背後にある永続化メカニズムには、自身が管理する永続オブジェクトについて、その変更の履歴を暗黙のうちに追跡する仕組みがなければいけない
    - 様々な方法のうち、２種類
        - 暗黙のコピーオンリード
        - 暗黙のコピーオンライト

- Hibenateによる実装
    - 二種類のリポジトリのうちどちらを作るにせよ、その作業は2つの段階に分かれる
        - 公開インターフェースを定義すること
        - そのインターフェースに対して実装をすること
        


### :question:疑問点
- Setの特徴を真似る、リポジトリから取ってきたものを書き直す必要をなくさなければいけない、というのがあまり考えになかった（ただの感想
- コレクション指向のリポジトリって、今も使われているんだろうか？ あまり聞かない気がする。
- ここまで、『何も意識させない』っていうのは本当に利点になるんだろうか？ 全てが全てこの方式で染まってないと難しい気がするが、できない場面が出てきそうでもある。特に他システムへのAdapter周りとか。



### :memo:書記欄
- コレクション指向のリポジトリって、今も使われているんだろうか？ あまり聞かない気がする。
    - 実装都合を外に追い出しているので、永続化という実現方式もまた、外に追い出されるべきもの。
    - ドメインの関心事ではない。

- 「コレクション指向のリポジトリは、オブジェクトのインメモリコレクションを模倣することを目的としています。いったん集合体がコレクションに追加されると、それに加えられた変更は、その集合体がリポジトリから削除されるまで自動的に保持されます。言い換えれば、コレクション指向のリポジトリは、add()やremove()のようなメソッドを持っていますが、保存のためのメソッドはありません。

- 一方、永続化指向のリポジトリは、コレクションを真似しようとはしません。その代わりに、外部の永続化ソリューションのためのファサードとして機能し、insert()、update()、delete()などのメソッドを含みます。アグリゲートに加えられた変更は、update()メソッドを呼び出してリポジトリに明示的に保存する必要があります。

リポジトリの種類はセマンティックに大きく異なるので、プロジェクトの最初にリポジトリの種類を取得しておくことが重要です。一般的に、永続性重視のリポジトリの方が実装が簡単で、既存のほとんどの永続性フレームワークで動作します。コレクション指向のリポジトリは、基礎となる永続化フレームワークがサポートしていない限り、実装が難しくなります。」

- コレクション指向のIFの方が、ドメインに関わる人の関心・活動を表現しやすそうかなーという気はしてます
- つまり、RDBMSの様に、集合として扱いづらいDBを使ってる際とかにそれをコレクションとして扱うのは逆に大変になるので、永続化志向を選択する方が楽になる適菜。

- Repositoryにメソッドが膨大にある場合はコレクションとして扱ってないですね。
    - FindやfindAllはまだOKとしても、FindByXxxxとか
    - CQRSの話になってくる
        - CQRSで嬉しいのは、Commandの都合とは別に、Query側の個別具体的な場面毎に、任意の（集合も含めた）構造を自由に定義できる、ということと理解してます
        - クエリ系は変更操作ではないのでいろんな条件でひっぱってこれない、クエリ系はID以外の検索も出てきます。なのでCQRSでコマンド系で使用するリポジトリから追い出しましょう。コマンド系は基本的には集約に対する操作です。なのでルートエンティティを識別するIDで検索する場合がほとんどです。なのでFindByIdだけで大部分を解決できるようになります。
        - それこそ「個別具体ごとに自由に作れる」のだから、会社毎男性従業員リスト#findBy(会社ID)と、ものすごい具体的なQueryサービスを自分だったら作るかなあという気がします
        - 実際のところはID指定で終わらせるというより、クエリを上手に組み立てるモジュールを作って従業員#select(query)とかかなあ、という気がします
        - QueryService.new.findByAgeIn(10,20) にしたいかなー
        - 10-20歳の画面データ#find();
        - DBMS的には、そこにビューを用意する  # 誰も訊いてない
---

## 12.２ 永続指向のリポジトリ

### :books:概要

永続指向は対象ストレージがNoSQLなどのキーバーリューストアの時に使用し、集約の情報全体をまとめて保存する。永続指向のリポジトリはコレクション指向のリポジトリが使えない時、つまり、永続化メカニズムにオブジェクトの変更を検出・追跡する機能がないときに適用する。

- コレクション指向のリポジトリとの違い
    - addメソッドやaddAllのは不要になるため削除する
    - 更新の場合は常にsaveが必要
- 永続化メカニズムによって振る舞いが大きく変わる可能性があるので、柔軟なインターフェースにする
    - メリット:永続化メカニズムを簡単に差し替えできる
    - デメリット:オブジェクトリレーショナルマップのせいで、必要な場面でsaveが行えない可能性がある
- 新しく作ったり、変更を加えたりしたオブジェクトはデータストアに明示的にputする
    - 常に更新ということになる
    - 変更を追跡したりトランザクションの境界をサポートしたりするユニットオブワークが提供されていない

```cs
namespace SaaSOvation.AgilePM.Domain.Model.Products
{
    public interface IProductRepository
    {
        ICollection<Product> GetAllByTenant(Tenants.TenantId tenantId);

        ProductId GetNextIdentity();

        Product GetByDiscussionInitiationId(Tenants.TenantId tenantId, string discussionInitiationId);

        Product Get(Tenants.TenantId tenantId, Products.ProductId productId);

        void Remove(Product product);

        void RemoveAll(IEnumerable<Product> products);

        void Save(Product product);

        void SaveAll(IEnumerable<Product> products);
    }
}
```

コレクション指向のリポジトリにあったAdd/AddAllメソッドはなく、明示的なSaveが必要である。

>永続化メカニズムはMapを真似たものである

これは、集約全体をMongoDBやLevelDBの1つのレコード（ドキュメント）として保存するため、AddメソッドではなくSaveメソッドを使う。それ以外はコレクション指向のインターフェイス設計と同じ。

永続指向のリポジトリのメリットとしては次のものがある

- それぞれの境界付けされたコンテキストや集約など、個別にチューニングしてスケーリングできる
- 他の境界付けされたコンテキストとは完全に切り離すことができる
    - クエリが誤って別の境界付けされたコンテキストのオブジェクトを返すことがない
- 特定の境界付けされたコンテキストの集約を返すようなFindメソッドが必要なった時、特別なクエリが不要
    - キャッシュ内のエントリ全てを返せばいい


### :question:疑問点
- 「デメリット:オブジェクトリレーショナルマップのせいで、必要な場面でsaveが行えない可能性がある」。これってどういうパターンがあるのだろう。

### :memo:書記欄
- とかで、実装に使えるDB操作が限定されることがあるから、とかいう話かしら。
- ActiveRecord的な、RDBを前提としたORMなら「レコードを追加する」ということで add がそのまま対応しそうな気がしますが。ドキュメント指向的なものを前提にしたORMだと、そもそもそのキーに「レコードが追加された状態のデータ全体」を新たに上書きすることになるという（これをORMって呼んで良いんだろうか）

---

## 12.3 その他の振る舞い

### :books:概要

集約はコレクションを模擬したものである。そのため、コレクション内のインスタンスの数を返す振る舞いも必要になる。

>C#の場合には、LengthやCountを実装する。

コレクションの場合には、Countがプロパティで用意されているので、これに合わせてプロパティを提供する。
- Javaの場合には、`size()` を提供する。これはjava.util.Collectionが提供するものと同じである

----

また、非機能要件を満たすためには一部の処理をデータストアに移す必要がある。こういった実装は、ドメインサービスの制御下に置くのが最適である。これは、ドメインサービスは、ステートレスなドメイン固有の操作を保持するために使用されているためである。

集約がルートから順にたどっていける場合、集約の一部だけを抽出することができる。この操作を実現するためだけに、アクセス権限を変えることはしてはいけない。アクセス権限を変えてしまうと、集約の契約違反になる。

>ショートカットアクセスを実装するのは、速度要件など非機能要件がどうしても満たせない場合に特別に行う

または、複数の集約を組み合わせた情報を取得したい場合は、複数の集約を組み合わせたコンテナを作成するのではなく、**ユースケースに最適化したクエリ**を適用する。ここでは、永続化メカニズムにたいして複雑なクエリを指定して、その結果を、ユースケース専用に作った値オブジェクトを動的に作成する

ただし、この**ユースケースに最適化したクエリ**を使うファインダーメソッドが数多く作成される場合には注意が必要である。この場合は、設計を見直し、集約の境界の再定義をするかどうかを検討する必要がある。または、CQRSを適用することを検討する。

### :question:疑問点
- P.415の最後-P.416「また、非機能要件を満たすためには一部の処理をデータストアに移す必要がある。こういった実装は、ドメインサービスの制御下に置くのが最適である。これは、ドメインサービスは、ステートレスなドメイン固有の操作を保持するために使用されているためである。」の内容を汲み取ると、リポジトリでは、ある程度のデータの塊をリポジトリ経由で、ドメインサービスが取得し、ドメインサービスの中でデータのフィルターをするイメージを抱きましたが、認識あっていそうですか？
- P.416「時には、集約のルートに直接アクセスするのではなく、集約の一部分だけをリポジトリから取り出したい場合もあるだろう。たとえば、集約の中に何かエンティティの巨大なコレクションがあって、その中から特定の条件にマッチするインスタンスだけを取得したい場合などだ」
    - これって、そもそも論で、そんな巨大な集約を作るなっていう感じがしないでもないですが、どうなんでしょう…。集約自体がでかいのではなくて、その集約のコレクション数が多い（＝データベースのレコードいっぱいある）みたいな感じなんですかね…
- P.416の「複数の集約を組み合わせた情報を取得したい場合は、ユースケースに最適化したクエリを使うことになる」と書かれているが、ユースケースに最適化したリポジトリを作るようなイメージ？
    - さらにここで、「ユースケース専用に作った値オブジェクトに動的に格納する」とあるが、これってDTOとどう違うんだろう？


### :memo:書記欄
- P.415の最後-P.416「また、非機能要件を満たすためには一部の処理をデータストアに移す必要がある。こういった実装は、ドメインサービスの制御下に置くのが最適である。これは、ドメインサービスは、ステートレスなドメイン固有の操作を保持するために使用されているためである。」の内容を汲み取ると、リポジトリでは、ある程度のデータの塊をリポジトリ経由で、ドメインサービスが取得し、ドメインサービスの中でデータのフィルターをするイメージを抱きましたが、認識あっていそうですか？
    - ドメインにまつわるものは全てプログラム内のドメインオブジェクトで実装する、という主義のようなので、イメージとしてはそういいたい文章だと思う。
        - コレクションのメソッドを用意するべきなので、そんな感じなのかな
    - DB側でやっている、ということを、ドメインサービスのメソッド内に閉じ込めて外からは観測できないように実装するような手段もあるよ、という文かと。
- P.416「時には、集約のルートに直接アクセスするのではなく、集約の一部分だけをリポジトリから取り出したい場合もあるだろう。たとえば、集約の中に何かエンティティの巨大なコレクションがあって、その中から特定の条件にマッチするインスタンスだけを取得したい場合などだ」
    - User集約を組み立てることなく、ActionLogだけ取り出すと、コード上は「ユーザーに全く紐付かないActionLog」が存在することになりそうなのが気になります
    - ログを集約の一部にするのか、別の集約にするのか、どっちが適切かというのはあるけれど、そういうことですね。
    - 集約としては `User o--> "0..n" ActionLog` みたいな感じでミニマムなんだけど、ActionLogの件数が10,000超えてるみたいな。そういう時に、Userオブジェクトを組み立てるのでなく、必要なActionLogの一覧だけ取出して〜みたいなことをしたい誘惑に駆られるけど、それは集約の制約違反だよねみたいな理解です
    - これらの対策として、ユースケースに特化したクエリを作る。CQRSを使う。集約の境界を分ける

- P.416の「複数の集約を組み合わせた情報を取得したい場合は、ユースケースに最適化したクエリを使うことになる」と書かれているが、ユースケースに最適化したリポジトリを作るようなイメージ？
    - さらにここで、「ユースケース専用に作った値オブジェクトに動的に格納する」とあるが、これってDTOとどう違うんだろう？
        - 最近、実際に「画面表示ではxという項目ほしいけど、それ以外の計算場面では別にxはほしくない（下手するとノイズ）」みたいなシーンが有ってその時は、ドメインモデルとは別にReadModelとReadModel専用のRepository立てました
---

## 12.4 トランザクション管理

### :books:概要

トランザクション管理をする場合、ドメインモデル及びドメインレイヤは不適切である。トランザクション管理はアプリケーションレイヤもしくはユーザーインターフェースレイヤで実装するべきである。

- アプリケーションレイヤに実装する場合
    - [ファサード](http://www.techscore.com/tech/DesignPattern/Facade.html/)を使って実装する
        - 複雑な処理の呼び出しを単純化するためのパターン
        - 単純な呼び出しの窓口を用意し、複雑なサブシステムの組み合わせを行う
        - サブシステムの詳細を知る必要がなくなり、サブシステムの実装から解放される
    - ユースケースのフローごとに1つの関数にする
        - ユースケースに必要なフローをまとめる
        - ファサードパターンを使って呼び出しを単純化する
- ユーザーインターフェースレイヤに実装する場合もファサードパターンを適用する

どちらのパターンを適用する場合でもファサードを適用する。そこで、ファサードパターンを適用し、トランザクション処理を単純化する。

```cs
public class SomeApplicationServiceFacade {
    public void DoSomeUseCaseTask()  {
        Transaction transaction = null;
        try {
            transaction = this.Session().BeginTransaction();
            // use the domain model ...
            transaction.Commit();
        } catch (Exception e) {
            if (transaction != null) {
                transaction.Rollback();
            }
        }
    }
}
```

ファサードパターンの実現方法はドメインモデルの呼び出しによって実現する

どのようなデータベースを使い永続化を実現しても同様の実装が行える。つまり、アプリケーションレイヤが管理するセッションやユニットオブワーク、トランザクションにアクセスする手段を組み合わせることでトランザクション管理を行う。

#### トランザクション管理の注意点

ドメインモデルとトランザクションの組み合わせは多用するべきではない。集約を設計する場合には、整合性の境界を正しく保証するべきである。

>トランザクションはドメインモデルを組み合わせるため、整合性の境界を越境する

単一のトランザクション内で複数の集約への変更を行うと、整合性が保てなくなる可能性がある。

### :question:疑問点
- P.417のサンプルコードの `DoSomeUseCaseTask` メソッドがファサードで、その中でトランザクションを使うイメージなんですね（という今更ながらの気づき
- P.417 『モデルに関連付けられた操作は通常、地震でトランザクションを管理する程度に細かな粒度になっており、そのライフサイクルの中でトランザクションを気にするべきではない。』 と書いてあるのって、何かおかしい気がするんですけどそうでもない？　(モデルは、トランザクション管理するには細かすぎる、というイメージ)

### :memo:書記欄
- P.417 『モデルに関連付けられた操作は通常、地震でトランザクションを管理する程度に細かな粒度になっており、そのライフサイクルの中でトランザクションを気にするべきではない。』 と書いてあるのって、何かおかしい気がするんですけどそうでもない？　(モデルは、トランザクション管理するには細かすぎる、というイメージ)
    - 誤訳じゃないですかね
    - モデルに関連するオペレーションは、通常、それ自体がトランザクションを管理するには細かすぎるし、 トランザクションがそのライフサイクルの一部を担っていることを認識すべきではない。モデルにトランザクションの懸念を置かないようにするためには、トランザクションはどこに属しているのでしょうか？

---

## 12.５ 型の階層

### :books:概要

集約をまたいだ継承を利用した型の階層を適用する際には注意が必要である。密接に関連し、交換可能であって多態性をもつような型どうしを階層にまとめる。この場合、リスコフの置換原則を満たす必要がある。

- ドメインに特化した集約型の階層を作った場合
    - 共通のリポジトリを用意するようになる
    - 提供するファインダーメソッドは共通のスーパークラスを返す
    - 個々の型を返す実装ではクライアントが集約内のどの識別子がどの型インスタンスを返すか知る必要がある
        - 多くの知識が無いクライアントは使うことが出来ない
- 一意な識別子を集約型の情報に納める暫定対策では2つの問題が発生する
    1. 識別子から型の情報を取得して、識別子を型にマッピングする処理を、クライアントに要求する
    2. クライアントと型ごとに違う操作とが密に結合する
        - クライアントが型に依存する
        - リファクタリング対象のコードになる可能性が高い
- 型を識別するための情報を、識別子ではなく、集約のプロパティで提供する
    - 単一の集約型の内部で、明示的な標準型に基づいた様々な機能を提供できる
    - 型情報がクライアントから見えやすくなる

### :question:疑問点
- P.422の最初「継承を活用して方の階層を作りたくなることがある」の例がぱっと思い浮かばなかったので、何か経験がある人いたら教えてほしいです


### :memo:書記欄
- センサーの種類だったり、ワークフローの詳細な内容としては色々違いがあるけど、一段メタな視点からは「センサー」「ワークフロー」という荒い枠組みで一括して扱いたい。そういう場合には、個別のセンサー/ワークフローは、「センサー」「ワークフロー」を継承したものとして作る気がします
- ワークフローのドキュメントが複数種類あるけれど、ワークフローとしては同じように流せるようにしたい → 継承で、みたいのとか。
- 継承と言いつつ、専ら使うのは extends じゃなくて implements かも
- 個別のサブクラスで実装変わったら困る部分は、骨格クラスを間に挟んでextendsします
- 型階層のための継承なので、クラスの実装継承でなく、インタフェース継承も含めた話ですね
- JSONシリアライズしてリポジトリに保存するなら基底クラスにtoJsonとか作りたくなるかも
- 自分も言葉としてはインタフェースは「実装」って言いますけど、「型階層のための〜」っていう文脈だと、「継承」でも不思議と違和感覚えませんでしたね
- インタフェースを継承してインタフェースを作りますよね。
- クラスを継承してクラスを実装するのは、抽象クラスのインタフェースと実装の両方を継承している、です。
---

## 12.6 リポジトリのデータアクセスオブジェクトとの比較

### :books:概要

リポジトリとはDAO(Data Access Object)を違う名前で呼んだものではない

- DAO
    - データベースのテーブルに対してCRUDインターフェースを提供する
    - テーブルモジュール・テーブルデータゲートウェイ・アクティブレコードパターンが該当する
    - トランザクションスクリプトのアプリケーションで採用される事が多い
    - つまり、データベースのテーブルに対するラッパーとして用いられる傾向がある
- リポジトリ(もしくはデータマッパー)
    - オブジェクトとの親和性が高い
    - ドメインモデルと組み合わせて使われることが多い

集約自身にはビジネスロジックなどの内部処理を管理させ、それ以外を実装するべきではない。つまり、DAOやそれに関連するパターンを使うことで、集約の一部とみなされるようなデータに対して、きめ細かなCRUD操作を提供することはドメインモデルと組み合わせて使うことは避けるべきである

>非機能要件を満たせない場合のみ、この組み合わせを適用する

リポジトリを設計する際は、データアクセス指向ではなく、コレクション指向で設計をするべきである。データとその永続化を管理する仕組みとしてのCRUD操作よりも、ドメインモデルに集中できるようにするべきである。


### :question:疑問点


### :memo:書記欄
---

## 12.7 リポジトリのテスト

### :books:概要

リポジトリのテストには2つの観点がある

1. リポジトリ自体が正しく動作するか
    - プロダクトコードと同様の実装が必要
2. 必要な機能を提供しているか
    - 作った集約を格納できるか
    - 既存の集約を取り出せるか
    - 取り出した集約が正しく操作できるか
    - Mockを使って評価が可能

#### リポジトリ自体が正しく動作するかのテスト

「リポジトリ自体が正しく動作するか」のテストコードの例を示す

```cs
public class CoherenceProductRepositoryTest {
    private ProductRepository product_repository;
    private TenantId tenant_id;

    [ClassInitialize]
    public static void SetUp() {
        this.SetProductRepository(new CoherenceProductRepository());
        this.tenant_id = new TenantId("01234567");
        super.SetUp();
    }

    [ClassCleanup]
    public static void TearDown() {
        List<Product> products = this.product_repository.AllProductsOfTenant(tenant_id);
        this.product_repository.RemoveAll(products);
    }

    [TestMethod]
    public void TestSaveAndFindOneProduct() {
        Product product =
            new Product(
                    tenant_id,
                    this.product_repository.NextIdentity(),
                    "My Product",
                    "This is the description of my product.");
        this.product_repository.Save(product);
        Product read_product =
            this.product_repository
                .productOfId(tenant_id, product.ProductId);
        AssertNotNull(read_product);
        AssertEqual(read_product.TenantID, tenant_id);
        AssertEqual(read_product.ProductId, product.ProductId);
        AssertEqual(read_product.Name, product.Name);
        AssertEqual(read_product.Description, product.Description);
    }

    [TestMethod]
    public void TestSaveAndFindMultipleProducts() throws Exception {
        Product product1 =
            new Product(
                    tenant_id,
                    this.product_repository.NextIdentity(),
                    "My Product 1",
                    "This is the description of my first product.");
        Product product2 =
            new Product(
                    tenant_id,
                    this.product_repository.NextIdentity(),
                    "My Product 2",
                    "This is the description of my second product.");
        Product product3 =
            new Product(
                    tenant_id,
                    this.product_repository.NextIdentity(),
                    "My Product 3",
                    "This is the description of my third product.");
        this.product_repository
            .SaveAll(Arrays.asList(product1, product2, product3));
        AssertNotNull(this.product_repository
            .productOfId(tenant, product1.ProductId));
        AssertNotNull(this.product_repository
            .productOfId(tenant, product2.ProductId));
        AssertNotNull(this.product_repository
            .productOfId(tenant, product3.ProductId));
        List<Product> all_products =
            this.product_repository.AllProductsOfTenant(tenant);
        AssertEqual(all_products.Count, 3);
    }
}
```

クライアントコードを模擬するように一連の動作を確認する。

#### 必要な機能を提供しているかのテスト

必要な機能を提供しているかテストをする場合には、実環境で使用するDBを使用する必要はない。DBの準備や実行速度で問題がある場合、インメモリを使用してテストを実行する。

>インメモリと実環境のDBの切り替えはインターフェースを使うもしくはMockを使用する

### :question:疑問点
- P.426のリポジトリ自体が正しく動くかどうかを確かめるサンプルテストコードと、振る舞いのテストコードの違いがよくわからない…。`save()`を使っているか否かの話？


### :memo:書記欄
- 内部実装のテストは、実際のリポジトリクラスでないと意味ないし、外部仕様のテストは、インタフェースが守られていればいいのでモックでいい、ですね。
- 前者がp.426~から書いているテスト。後者のテストはp.429~から書いているテスト

---
## 12.8 まとめ
### :books:概要

この章で学んだこと

- コレクション指向および、永続指向のリポジトリについて、それぞれをどんあんときに使うのかを学んだ
- HibernateやtopLink、Coherence、そしてMongoDBでのリポジトリの実装方法を見た
- リポジトリのインターフェースに追加の振る舞いが必要になる理由を調べた
- リポジトリを使う際の、トランザクションの扱い方を検討した
- 型の階層がある場合に、リポジトリを設計する際の、注意事項を理解した
- リポジトリとデータアクセスオブジェクトの根本的な違いを見た
- リポジトリをテストする方法や、リポジトリを使ったテストを行うためのそれぞれ異なる方法を知った


### :question:疑問点

複雑な絞り込みのクエリをRepositoryにメソッドとして用意しつつ、どの絞り込みメソッドを実際に使うか = どのような絞り込みルールが存在するかは仕様オブジェクトという形で切り出す、みたいなアプローチがEvans本にあった記憶

Repositoryと仕様パターンの組み合わせ、というアプローチは個人的にちょっと気になってる感じです
p.233~p.237 ぐらいですね
9章 仕様パターンの章です

selectWhereGracePeriodPast という「特殊なクエリ」をRepositoryは提供しつつ
「延滞請求書仕様」というものは仕様オブジェクトでくくりだし、その実現方法は↑の「特殊なクエリ」を叩く、という形で明示される

### :memo:書記欄

---


## 輪読会感想ふりかえり用

## 読書会進め方ふりかえり用

## その他、メモとか用の領域


