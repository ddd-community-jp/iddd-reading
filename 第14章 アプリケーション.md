## 14.1 ユーザーインターフェース

### :books:概要

利用者が操作するユーザーインターフェイス層のソフトウェア例をいくつか挙げる。

- サーバー側で処理するWebシステム
- ブラウザ側で描画するWeb APIサービス
- WinFormsやSWTやSwingといったネイティブ「GUIクライアント」
- スマートフォンアプリケーション

UI層は、利用者に使い勝手の良いユーザーインターフェイスを提供することが責務である。

----

UI層で重要な考察事項は次の2つある

- ドメインオブジェクトをどのようにレンダリングするか
- ユーザの操作をどのようにモデルに反映するか

#### ドメインオブジェクトのレンダリング

ドメイン層の情報をどのようにUI層に受け渡すかについて整理する。ユーザーインターフェースに表示されるデータは、必要最低限のデータだけでなく、付帯情報も一緒に表示されている方が使い勝手が良い。下の図にUI層と集約の関係を示す。

UI層は一つだけの集約の状態を変えることが多いが、表示のためには複数の集約から情報を取得する。ドメイン層とUI層間における情報の受け渡し方法を図示化すると次のようになる。

UIで描画する場合、複数の集約にアクセスして情報を取り出す必要があります。こういった情報を、UI層に受け渡す方法として次の3パターンがある

1. 複数の集約情報をDTOへ詰め替え
2. 複数の集約へ参照を保持するDPOを返送
3. ユースケースに最適化したクエリによる取得

##### 複数の集約情報をDTOへ詰め替え

複数の集約のインスタンスを使って単一のビューにレンダリングをする際にはデータ変換オブジェクト(DTO: Data Transfer Objects)を使用する。

>(DTO: Data Transfer Objects  
>デザインパターンの一種で、アプリケーションソフトウェアのサブシステム間(異なるレイヤー間)でデータを転送するのに使う

DTOを使ったレンダリングは次の手順で実現する

1. アプリケーションサービスは、リポジトリを使って必要な集約のインスタンスを読み込む
2. 集約をDTOアセンブラに移譲する
3. DTOアセンブラはDTOに属性をマッピングする
    - レンダリングに必要な情報をすべて保持する
4. UI層でDTOから情報を抽出し、ビューにレンダリングする

DTOアセンブラでは集約とUI層の問題を解決する

- 遅延読み込みのコレクションへの対応
- 複数の集約へのアクセス
- プレゼンテーション層とビジネス層の接合
    - 物理的に離れている場合にも対応する
    - ネットワーク越しに情報を取得し、データをシリアライズする

このパターンは実装が複雑化する傾向があるので、単一マシン内で閉じたアプリケーションでは使用しない傾向がある。ただし、このパターンを使わない選択をしたとき、クライアントと集約の内部構造が強く結びつく事があるので、注意が必要である。

モデルとクライアントの密結合を避ける方法として、[Mediatorパターン](http://www.techscore.com/tech/DesignPattern/Mediator.html/)を適用する。クライアントはMediatorインターフェースを実装し、集約へのオブジェクト参照にアクセスする。集約はMediatorインターフェースを介してリクエストされた内部状態を公開する。ただし、集約の構造や形状を外部に漏らすのではなく、集約の状態をレンダリングすることを心がける。

```cs
public class BacklogItem  : EntityWithCompositeId {

    public void ProvideBacklogItemInterest(BacklogItemInterest interest) {
         interest.InformTenantId(this.GetTenantId().Id);
         interest.InformProductId(this.GetProductId().Id);
         interest.InformBacklogItemId(this.GetBacklogItemId().Id);
         interest.InformStory(this.Story);
         interest.InformSummary(this.Summary);
         interest.InformType(this.GetType().ToString());

    }

    public void provideTasksInterest(TasksInterest interest) {
         List<Task> tasks = this.AllTasks();
         interest.InformTaskCount(tasks.Count);
         foreach (Task task in tasks) {

         }
    }

}
```

##### 複数の集約へ参照を保持するDPOを返送

DTOが不要な場合は、ビューのレンダリングに必要な複数の集約のインスタンス全体を、単一のドメインペイロードオブジェクト(DPO)にまとめる。

>ペイロードとは搭載物やデータ本体を指すが、DPOでは集約そのものを指す。つまり、1つのDPOは複数の集約のインスタンスを保持し、レイヤー間で受け渡しを実現する

DPOのメリット・デメリットをまとめると次のようになる

- メリット
    - 論理的なレイヤをまたがってデータ群をやり取りをするオブジェクトの設計がシンプルになる
    - 詰め替えに伴うメモリ消費が小さい
        - 既存のインスタンスをそのまま使うことでメモリ消費を抑える
- デメリット
    - DTOと同様にDPOを利用するレイヤー(UI層)にドメインモデルを公開しなければいけない
    - 集約のプロパティに遅延ロード項目がある場合は事前にロードしておく必要がある
        - 早期読み込み方式
        - ドメイン依存リゾルバ

##### ユースケースに最適化したクエリによる取得

ユースケースで最適化したクエリをリポジトリに用意し、値オブジェクトを返す。これは、リポジトリにファインダーメソッドを用意しておき、複数の集約を組み合わせたカスタムオブジェクトを返す。その情報をDTOではなく値オブジェクトに設定して返す。

>あくまで、ユースケースのフローに特化したDTOではなく、業務ドメインに特化した値オブジェクトを用意するアプローチになる

CQRSと似ているが、ユースケースに対応した処理をドメイン層に用意して、リポジトリで最適化している。

#### 複数クライアントに対応するための出力形式の切り替え

複数クライアントに向けた開発では、複数のクライアントの要望に対してJSON形式やXML形式など出力を分ける場合がある。こうした要望に対して、「データトランスフォーマ」と呼ばれる仕組みを用いて出力形式を切り替える方法が取られる。

>例:カレンダーの週次情報を表示するシナリオ  
>「CalendarWeekCSVDataTransformer」「CalendarWeekJSONDataTransformer」「CalendarWeekDTODataTransformer」のように欲しい形式名で指定する

ただし、この場合はDIを適用して、データトランスフォーマーの依存性を注入する方法もある。この方が設計がシンプルになる。

#### ユーザの操作をどのようにモデルに反映するか

プレゼンテーションモデルをアプリケーションサービスやドメインモデル周りの力仕事を請け負うファサードではない。プレゼンテーションモデルとアプリケーションサービスやドメインモデルの間に、より複雑な力仕事を担当するサービスを用意し、処理を委譲する。

##### 引き渡し用のアダプターと、ユーザーによる編集処理

データの表示とUIの制御だけ行い、他の処理をしない場合には、ビューのレンダリングには2つのパターンがある。

- ビューが、プレゼンテーションモデルにもとづいて自分自身をレンダリングする
    - プレゼンテーションモデルとビューを分離できる
- ビューをプレゼンテーションモデルがレンダリングする
    - テストは容易だが、プレゼンテーションモデルとビューが結合してしまう

ここでは、プレゼンテーションモデルがヘキサゴナルアーキテクチャのポート＆アダプター方式を採用している状態になる。つまり、1つのポートに対して、出力フォーマット別にアダプターを提供するイメージになる。

この仕組みによってクライアントは、データトランスフォーマの型を指定してアプリケーションサービスを呼び出すことで、任意のデータ形式を取得できるだけでなく、様々な手法と組み合わせることもできる。

#### ドメインモデルを利用するアーキテクチャ

UI層で描画するデータはドメインモデルから取得する。ドメイン層を取り囲むアーキテクチャとしては以下のパターンが存在する。

機能やチーム状況に応じてアーキテクチャは変化するが、基本的な方式として、UI層が、アプリケーション層の「アプリケーションサービス」を使用し、ドメインモデルを呼び出す流れになる。


### :question:疑問点
- P.495 「もともとDTOパターンが編み出されたきっかけは、リモートのプレゼンテーション層でDTOのインスタンスを扱いたいという要求だった」
    - リモートのプレゼンテーションってなに？
- P.498 『読み込みだけのトランザクションであっても、アプリケーションサービスのメソッド終了時にはコミットされるのが一般的だ』
    - ・・・つまりどういうこと？　読み込みでトランザクション使うの？
    - RDBのトランザクションとは違うのかな？と思ったけど、コミットって言葉使ってるし・・・
- ドメインペイロードオブジェクトの具体的な実装がよくわからん
    - P.497の「ドメインペイロードオブジェクトからの集約インスタンスのレンダリング」にかかれていた、複数集約をまとめる方法らしいが…？
- ドメイン依存リゾルバ、データトランスファーの開設あんまり載ってないけど、これらはどういう意味？
- インターフェース→プレゼンテーションモデル→アプリケーションレイヤという感じで、間にプレゼンテーションモデルを挟むメリットがまだよくわかっていない。


### :memo:書記欄
- リモートのプレゼンテーションってなに？
    - RPC全般な話でも、クライアント表示用のデータを送付するパターンってことでいいかと。
    - インフラ層が直接外部と繋がるってことはないかもですね。
    - 小林さんがイメージされてるのは、呼び出す側の時だけですね。外からは見えないです。内から外に繋げたい時にインフラを通って相手のプレゼンテーションにいくっていうか。
- P.498 『読み込みだけのトランザクションであっても、アプリケーションサービスのメソッド終了時にはコミットされるのが一般的だ』
    - サーバー内部のやり取りなら必要になるまで遅延できた読み込みが、外部に提供する際は事前に全部取得しないと、返すデータが返せない（ので、遅延が活かせず辛い）ということなのかなーと思ってました
    - でも、まとめて返す必要がある（まとめて返したくなる）なら、それはまとめて取得するべきものなのではというお気持ち
    - 必要になるタイミングが大きくずれる知識があるなら、それはクライアントに別タイミングで別のAPI叩いてもらえば良いのでは
    - 自分がやった処理だけでなく、最終的に応答するタイミングでの最新状態を返したければ、遅延読み込みが正しいこともある。
    - 複数の集約をまとめて渡す
    - A. DPOは複数の集約を突っ込むものなので、それらの間の整合性を保つためにトランザクションをかけて、正常終了ということで読み込み完了時にコミットする。

- ドメインペイロードオブジェクトの具体的な実装がよくわからん

- ドメイン依存リゾルバ
    - 強制的なアクセスをして、遅延読み込み
- インターフェース→プレゼンテーションモデル→アプリケーションレイヤという感じで、間にプレゼンテーションモデルを挟むメリットがまだよくわかっていない。
    - ViewModelかなと。
        - VMを書き換えたら、Viewが
    - アプリケーションとして必要な知識と、プレゼンテーションに必要な知識とが、一致する保証が無いからかなと

- 原文だと「 more than」なので、step1は含まれないですね


---
## 14.２ アプリケーションサービス

### :books:概要

アプリケーションサービスとは、**アプリケーション層に存在するドメインモデルの直接のクライアント**である。(アプリケーション層の位置はヘキサゴナルアーキテクチャ/レイヤー化アーキテクチャ参照)

アプリケーションサービスの責務は、タスクの調整であり、ユースケースのイベントフローごとにメソッドを提供する。アプリケーションサービスはあくまで調整役のため、薄い処理を行うだけのレイヤーである。この点でビジネスロジックを持つドメインサービスの対局にあると言える。

>アプリケーションサービスとドメインサービスの違いは明確な違いがある。ビジネスドメインのロジックを扱うものがドメインサービスであり、アプリケーションサービスはモデル上のタスク調整を実現する

アプリケーションサービスの調整対象には、次のものが考えられる

- 単一の境界づけられたコンテキスト
- 複数のコンテキストにまたがるもの
- データベースのトランザクションといったコントロールを行う

----

アプリケーションサービスでクライアントの要望に対応する方法としては次の2パターンがある

- データトランスフォーマーを使い、各種のクライアントに対して、それぞれが必要とするデータ型を用意する
    - データ型ごとに関数を用意する
        - CalendarWeekCSVDataTransformer
        - CalendarWeekDPODataTransformer
        - CalendarWeekDTODataTransformer
        - CalendarWeekJSONDataTransformer
        - CalendarWeekTextDataTransformer
        - CalendarWeekXMLDataTransformer
    - 関数が用意されていない場合には新しいトランスフォーマーを用意する
- ヘキサゴナルアーキテクチャのポート&アダプター方式を適用する
    - 標準の出力ポートは1つ
    - クライアントの種類ごとに任意の数のアダプターを用意する
        - 出力ポートは、特定の名前のポートを付与する
        - 出力ポートは、アプリケーションの境界に位置する
    - 各ポートは出力ポートインターフェースを実装している
        - ポートは任意の数のリーダーを保持できる
            - Publisher-Subscriberパターン
        - ポートのインスタンスはドメインが管理する

ポート&アダプター方式を実装した例を以下に示す

```cs
public class TenantIdentityService {
    public void ProvisionTenant(
            String tenant_name,
            String tenant_description,
            boolean is_active,
            FullName administrator_name,
            EmailAddress email_address,
            PostalAddress postal_address,
            Telephone primary_telephone,
            Telephone secondary_telephone,
            String time_zone) {
        Tenant tenant = this.TenantProvisioningService.ProvisionTenant(
                        tenant_name,
                        tenant_description,
                        is_active,
                        administrator_name,
                        email_address,
                        postal_address,
                        primary_telephone,
                        secondary_telephone,
                        time_zone);
        this.TenantIdentityOutputPort().Write(tenant);
    }
}
```

ポート&アダプター方式の弱点は、**クエリを実行するアプリケーションサービスのメソッドの命名が難しい**ことである。これは、「Provision(供給する)」という単語を用いているが、戻り値はvoid型で何も戻してはいない。

Publisher-Subscriberパターンの意味合いを強くすると次のような実装になる。

```cs
public Tenant ProvisionTenant(
    string tenant_name,
    string tenant_description,
    FullName administor_name,
    EmailAddress email_address,
    PostalAddress postal_address,
    Telephone primary_telephone,
    Telephone secondary_telephone)
{
    try
    {
        // must be active to register admin
        Tenant tenant = new Tenant(this.tenantRepository.GetNextIdentity(), tenant_name, tenant_description, true);

        // Since this is a new entity, add it to
        // the collection-oriented repository.
        // Subsequent changes to the entity
        // are implicitly persisted.
        this.tenantRepository.Add(tenant);

        // Creates user and role entities and stores them
        // in their respective repositories, and publishes
        // domain events UserRegistered, RoleProvisioned,
        // UserAssignedToRole, and TenantAdministratorRegistered.
        this.RegisterAdministratorFor(
            tenant,
            administor_name,
            email_address,
            postal_address,
            primary_telephone,
            secondary_telephone);

        DomainEventPublisher.Instance.Publish(new TenantProvisioned(tenant.TenantId));

        return tenant;
    }
    catch (Exception e)
    {
        throw new InvalidOperationException(
            string.Concat("Cannot provision tenant because: ", e.Message), e);
    }
}
```

### 実装例

インターフェースを設計する際にはシグニチャを十分に検討する。インターフェースでモデルの型を使用する場合には、インターフェースがモデルの型を知っている必要がある。また、対象のインターフェースを実装するクラスは使用している型に依存する。

モデルの型を使うことで、強力な型チェックや基本的なバリデーションが得られるが、依存関係や結合状態になってしまう。

>モデルの型を使うかプリミティブな型を使うかはどちらもメリット・デメリットがあるため、適宜判断する必要がある

データトランスフォーマーを使用することで全てのモデルの型を公開する必要はなくなる。

### :question:疑問点
- P.50４-505の アプリケーションサービスメソッドのシグネチャに、ドメインモデルを出すパターン、コマンドモデルを使うパターン、プリミティブな値のみを使うパターンがあると思うが、みんなよく使うのはどのパターンだろう。
    - アプリケーションサービスのメソッドに渡す時の値のチェック（nullかどうかなど）は、プリミティブな値やコマンドオブジェクトを渡すようにしたら、アプリケーションサービスメソッドの中でやらないとダメそう
- P.508 『もしアプリケーションサービスが**ステップ1**以上のことを行おうとしているのなら、ドメインロジックがモデルの外部に漏れてしまっている恐れがある。』の
  **ステップ1** とは、『アプリケーションサービスで ① 新しい集約 Tenant のインスタンスを作成し、リポジトリに追加する』 という部分のこと？
    - もしそうなら、そもそもアプリケーションサービスでこのステップ1をやるのすら、漏れている気がするのだけどどうなんでしょう。


### :memo:書記欄
- - P.508 『もしアプリケーションサービスが**ステップ1**以上のことを行おうとしているのなら、ドメインロジックがモデルの外部に漏れてしまっている恐れがある。』の
  **ステップ1** とは、『アプリケーションサービスで ① 新しい集約 Tenant のインスタンスを作成し、リポジトリに追加する』 という部分のこと？
    - ②③はドメインのやること。①は、Repositoryの操作だから、アプリケーションサービスのところでやるよ

---
## 14.3 複数の境界づけられたコンテキストの合成

### :books:概要

1つのUI画面にて、複数の境界づけられたコンテキストの情報を合成されていることを意識せずに扱う必要がある場合を想定する。

>例  
>3つのコンテキストをアプリケーションサービスでまとめる必要がある場合

この対応策として大きく次の2つの方法がある

- 複数の境界づけられたコンテキストに対して、アプリケーション層からアクセスして合成する方法
    - 最も手軽な方法で、アプリケーションレイヤがユースケースを管理する
    - オブジェクトの集約と、UI向けの包括的なオブジェクトを作成する
        - ビジネスロジックは含まれない
    - UI層とアプリケーション層の名前は、合成の目的であるコンテキストに沿ったものになる
- 境界づけられたコンテキストを新しく作る方法
    - このコアドメインは、新しいモデルと腐敗防止層から構成される軽量な役割になる
        - 別の境界付けされたコンテキストから情報を収集する
    - トランザクションスクリプトであり、ドメインモデル貧血症になる
    - 実装面でメリットがあるため、コンテキストとして割り切る

どちらの方法を選ぶかという基準は、**ビジネス上のメリットが大きいほう**を基準にする。

#### UI層での描画に関わるモデル

UI側での描画について考察する。

UIを描画するフレームワークは次の2つから構成される事が多い

- ビュー:UIの表示(描画)を行う
- プレゼンテーションモデル:UIの状態とUI固有ロジックを持つ

このとき、プレゼンテーションモデルの状態に従ってビューが画面のレンダリングを行う

----

ここで、システム全体に存在するモデルを整理する

- ドメインモデル
    - ユビキタス言語を用いて、ビジネスや業務そのものを表現する
- DTO/DPO
    - クライアントに対して、ユースケースに応じたデータ構造の公開と受け渡しを担当する
- プレゼンテーションモデル
    - 画面の内容を抽象化し、UI固有の振る舞いを担当するモデル
    - 画面に必要な機能は、プレゼンテーションモデルに属する
        - UIのニーズに合わせたプロパティや振る舞いを持つ
        - 必要な情報をドメインモデルから取得する
    - RESTfulで提供するリソースもプレゼンテーションモデルに該当する

##### ［コラム］UI層にドメインモデルを公開するかの判断

DPOを利用する場合、UI層からドメインモデルを見ることができる。逆にDTOを利用する場合、UI層に対してドメインモデルを隠すことができる。この両者の設計指針は以下の通り。

| 項目 | ドメインモデル公開時 | ドメインモデル非公開時 |
|----|----|----|
| 性能 | ￮(変わらない) | △(DTO詰め替えによるメモリ使用とガベージコレクションコストが発生) |
| 依存関係 | △(ドメインモデルへの依存性が高く結合度が高い) | ￮(ドメインモデルへの依存がなく結合度が低い) |
| 型による妥当性チェック | ￮(使える) | △(使えない) |
| コード量 | ￮(増えない) | △(DTO部分や詰め替え部分が増える) |
| 複数クライアント時の対応 | △(ドメインモデルにおいて影響がないように複数クライアントを考慮する) | ￮(複数クライアント別にDTOを用意するためドメインモデルに影響がない) |

ドメインモデルを公開すればユビキタス言語で使いやすく、バリデーションチェックが有効なモデルを利用できるといったメリットがある。しかし、UIとドメインモデルが密結合となるため相互に変更の影響を受けやすくなる。

一方、ドメインモデルを非公開にすれば、UI層は、DTOとプリミティブ型（Int,String等）のみを参照することになる。これによりUIとドメインモデル間を疎結合にできるが、中間的なメッセージモデルへの詰め替えコードが冗長になってしまう。

### :question:疑問点
- P.513 の「ポータル・ポートレット形式」とはなにか
- P.513 の「このアプリケーションレイヤは、新しいドメインモデルと組み込みの腐敗防止層からなるものではなかったのだろうか？〜」という下りの話は、『アプリケーションレイヤは、組み込み型とドメインモデルを住み分ける為の腐敗防止層という見方もできる』という解釈で合っている？


### :memo:書記欄
- P.513 の「ポータル・ポートレット形式」とはなにか
    - https://jp.cybozu.help/g/ja/admin/application/portal/
    - マイクロフロントエンド的な？
        - https://tech.mercari.com/entry/2018/12/06/162827
- P.513 の「このアプリケーションレイヤは、新しいドメインモデルと組み込みの腐敗防止層からなるものではなかったのだろうか？〜」という下りの話は、『アプリケーションレイヤは、組み込み型とドメインモデルを住み分ける為の腐敗防止層という見方もできる』という解釈で合っている？
    - あってそう

---
## 14.4 インフラストラクチャ

### :books:概要

インフラストラクチャの役割は、**アプリケーションのその他の部分に対して、技術的機能を提供すること**である。インフラストラクチャに対してはDIP(依存性逆転の原則)を適用し、ドメインモデルが詳細と結合しないようにする。

インフラストラクチャがアーキテクチャ上のどこにあっても、必要なインターフェースを実装している限りは結合関係に問題は生じない。上の図ではアプリケーションモデルはドメインモデルと結合している状態であり、インフラストラクチャとは結合していない(後から差し替えができる)

ここで意図した動作を実現するためには、依存性を注入してもいいし、サービスファクトリを使っても構わない。

>最終的には同じ機能を提供している

サービスファクトリを使ってリポジトリを提供する場合には次のようになる

```cs
public class TenantIdentityService {
    public Tenant Tenant(TenantId tenant_id) {
        Tenant tenant = DomainRegistry.TenantRepository.TenantOfId(tenant_id);
        return tenant;
    }
}
```

リポジトリの詳細な実装はインフラストラクチャ上に配置する。リポジトリはストレージなどの詳細を扱うためである。

### :question:疑問点


### :memo:書記欄
---
## 14.5 エンタープライズコンポーネントコンテナ

### :books:概要
- エンタープライズアプリケーションサーバは日常的に使われるものになっている。
- サーバyその中で動くコンポーネントコンテナに、何らかの革新があったわけではない
    - EnterpriseJavaBeans(EJB)をセッションファサードとして使ったり、シンプルなJavaBeansをSpringのようなIoCコンテナで管理して、アプリケーションサービスに使わせることができる
        - IoCについて
            - [IoCとService LocatorとDIの関係 \- yotiky Tech Blog](https://yotiky.hatenablog.com/entry/2018/09/28/IoC%E3%81%A8Service_Locator%E3%81%A8DI%E3%81%AE%E9%96%A2%E4%BF%82)
- 14章ではSpringを使うことを選んだが、別のエンタープライズコンテナに載せかることだって問題がない


### :question:疑問点
- Springのアノテーションが、アプリケーションサービスメソッドに付くことに対して若干違和感を覚えた（たぶん、そうするしか無いと思うんだけど）
    - たとえばSpring以外で実装する際には、アプリケーションレイヤのクラスごと新しいものを作ることになる？
    - それを見越して、アプリケーションレイヤのインターフェースは用意すべき？

### :memo:書記欄
---

## 14.6 まとめ

### :books:概要


### :question:疑問点


### :memo:書記欄

---


## 輪読会感想ふりかえり用

## 読書会進め方ふりかえり用

## その他、メモとか用の領域


