## 11.1 ドメインモデルにおけるファクトリ

### :books:概要

-  ファクトリを使う最大の動機とは
    -  複雑なオブジェクトと集約のインスタンスを生成する責務を、別のオブジェクトに移すこと
    -  複雑な組み立てをすべてカプセル化するインターフェースを提供すること
    -  集約全体をひとまとまりとして生成し、その不変条件を強調すること

- ファクトリは2パターンあり、
    - 特定の型をインスタンス化するだけのオブジェクト（単なるファクトリで、ドメインモデルの一級市民としてはみなされない）
    - 集約ルートの中に、別の型の集約のインスタンスファクトリメソッドもつ場合
        - 集約ルートの第一責務は、集約の振る舞いを提供すること。ファクトリメソッドも振る舞いの１つ

### :question:疑問点

- ファクトリのクライアントは主に、集約ルートか、ドメインサービスとなる？

### :memo:書記欄

- ファクトリのクライアントは主に、集約ルートか、ドメインサービスとなる？
    - 大体認識通り
    - デザインパターンのアブストラクトファクトリまで含めるともっと広がるかと

---
## 11.２ 集約ルート上のファクトリメソッド

### :books:概要

- 表11-1で、SaaSOvationの境界づけられたコンテキストでの、集約ルートと、ファクトリメソッドの場所

| 境界づけられたコンテキスト | 集約 | ファクトリメソッド |
| -------- | -------- | -------- |
| 認証・アクセスコンテキスト     | Tenant     | offerRegistrationInvitation() <br> provisionGroup() <br> provisionRule() <br> registerUser()     |
| コラボレーションコンテキスト | Calender <br> Forum <br> Discussion | scheduleCalenderEntity() <br> startDiscussion() <br> post() |
| アジャイルプロジェクト管理コンテキスト | Product | planBacklogItem() <br> scheduleRelease() <br> scheduleSprint() |

- P.377-379　ファクトリメソッド`scheduleCalenderEntity()`の引数については、値オブジェクトで全て構成されている。
    - そのため、ファクトリメソッド内であえてガード(不正な値を防ぐためのif文)を入れる必要はない

### :question:疑問点


### :memo:書記欄
---
## 11.3 ファクトリとしてのサービス

### :books:概要

- サービスをファクトリとして使う方法の多くは、境界づけられたコンテキストの統合に関わる
    - 13章で改めて説明をする
        - 13章では主に、腐敗防止層や公表された言語、公開ホストサービスとの統合を考える
        
- ファクトリそのものについて、サービスをファクトリとして設計する方法について説明する

### :question:疑問点

- P.383-384のコードサンプルだと、Domain層にサービスのInterfaceを配置してる。
    - 認証・アクセスコンテキストからデータを取得して、Authorオブジェクトに変換するという実装を、Infra層でやっている
        - これはRepositoryとまた別なのか？

- ファクトリとリポジトリの明確な違いってなんだろう？
    - DBとのアクセスをするのが、リポジトリ？
    - ファクトリは、データの生成をする手続きを閉じ込めたもの？

### :memo:書記欄

- P.383-384のコードサンプルだと、Domain層にサービスのInterfaceを配置してる。
    - エヴァンス本には、
      * ファクトリは新しくオブジェクトを作るのが責務で、
      * リポジトリは古いオブジェクトを再構築するのが責務だ
* 別コンテキストから来た値を元に、このコンテキスト内で使える形に「生成」する必要がありますね。
* これを一般的には腐敗防止層（ACL）で行う事により、
* 外部コンテキストのデータにより自コンテキストが汚染されないように考慮して生成します。
- Factoryで言うところの「生成」は「オブジェクトをnewする」ではなくて、「まだ存在しないエンティティを生成する」という意味なのかなと思いました
    - 生成は、プロセス内のメモリ上に作るかどうかではない、と。
    - new する = すべて新規作成みたいなイメージがあったのですね
    - あくまで新たな identify を持った Entity を生成ですね
    - GoFのファクトリパターンは前者の new するときのパターンなので全く別物と考えた方が良いですね。
    - オブジェクトを作る作らないが課題って感じですかね。

- GoFのFactoryが解決しようとしているのは「オブジェクトの複雑な生成方法を抽象化する」こと
- DDDのFactoryが解決しようとしているのは「エンティティを生む」という手続きの表現なのかなあと


---

## 11.4 まとめ
### :books:概要


### :question:疑問点

- いわゆる 「Factory パターン」 とはちょっと違うと思うのだけど、紛らわしい　っていう位の感想でいていいんだろうか？実は同じだったりする？

### :memo:書記欄

- 11.3 章の回答で解決。

---


## 輪読会感想ふりかえり用

## 読書会進め方ふりかえり用

## その他、メモとか用の領域


