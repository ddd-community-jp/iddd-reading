## 8.1 いつ（そしてなぜ）、ドメインイベントを使うのか
* Domain Eventの定義: 「ドメインエキスパートが気にかける、何かの出来事」
* イベントを外部のサービス(別の境界づけられたコンテキスト)に通知しないといけないケースがある。
  * こういうときはパブリッシャー、サブスクライバパターンを使うことになる。ローカルとリモートの境界づけられたコンテキストに広く影響を及ぼす。
* イベントを他のコンテキストに配送する際は、結果整合性を利用するのが一般的だ
* ドメインイベントを使うことで、バッチ処理を細かく分けてまんべんなく実行できる。
* 集約に対するコマンドのうち、無意味な出来事をイベントとして実装しないこともできる。イベントソーシングを使う場合や、システム間の協調の目標によっては、多くのイベントを用意することもできる。

### :books:概要

### :question:疑問点
- ドメインイベントを扱う＝イベントソーシングを扱う、みたいなイメージに捉えていたが、それは間違いか？
    - P276に、「しかし、そのモデルの技術的な実装や、あるいはシステム間の強調の目標などによっては、ドメインエキスパートが求めるよりも多くのイベントを用意することも出来る。たとえばイベントソーシングを使う場合などが、それにあたる」と書いてあるので、ドメインイベント扱う→ESとはならないのあかなぁ…と意味に取れる。

### :memo:書記欄
- ESではない、ですね。
    - 実現方法のひとつとして捉えておく
- 私はイベントがまずあって、応用としてESですね
- 究極の理想としてES
    - でかいシステムとかを扱う場合なら、使う？
- 銀行システムくらい?
- スマホとかゲームアプリとか、結果通知するパターンとして使うと良いのかな？
- pub sub は es　ですよ
    - ドメインイベントをpub sub で使うのがesって感じですね
- esじゃないpub sub はあっても es を実現するのは pub sub ですね
    - 私はpub subとESはイコールではないと思ってます。DBにイベントを保存するのがイベントソーシングの条件だと理解しています。
    - PubSubでのメッセージングにおいて、メッセージとしてドメインイベントを送る、という関係。

- 状態の保存の仕方として、2種類がある
    - ステートソーシング
    - イベントソーシング
        - 今までのステート

- イベントストアとイベントソーシングが1..1にはならない
    - イベントストアとイベントソース
        - イベントストアはデータベースの種類のひとつとして考える

- 参考: 本書でのイベントソーシング = 4.7節 (p.155)

---


---

## 8.2 イベントのモデリング

### :books:概要

- コマンドがイベントの発生要因なので、イベントの名前には、実行されたコマンドを用いるのが適切だ

* チームはバックログアイテムをスプリントにコミットするコマンド、イベントを設計した。
```
実行したコマンド: BacklogItem#commitTo(Splint aSprint)
その結果として発生するイベント: BacklogItemCommitted
```

- ↑は集約内でリクエストされた操作が成功したこと（バックログアイテムがコミット**された**こと）を表している。**過去形になっている**
- もう少し詳しい名前でも良いかもしれないが、集約からのイベントをパブリッシュｓるうときに重要なのは、その出来事が過去に発生したことがわかるような名前にすること
- 今まさに起こっていることではなく、**こういう出来事が発生した**ということがわかる、事実を反映した名前を選ぶのが望ましい

最終的なBacklogItemCommitedのクラス定義
```
public class BacklogItemCommitted implements DomainEvent {
  private Date occuredOn;
  private BacklogItemId backlogItemId;
  private SprintId committedToSprintId;
  private TenantId tenantId;
  ...
}
```

* イベントは通常不変クラスとして設計される
* イベントのインターフェイスには、イベントの発生要因を表すプロパティを伝えるという明確な目的がある。

- どんなプロパティが必要になるかを考える時、イベントを起こすきっかけとして、何が必要になるのかを採光すればよい
    - 通常は、イベントが発生した集約や、そのイベントにかかわったその他の集約を表す識別子が必要だろう

```
# ローカルの境界づけられたコンテキスト内のサブスクライバ
MessageConsumer.instance(messageSource, false)
    .receiveOnly(
            new String[] { "BacklogItemCommitted"},
            new MessageListener(Type.TEXT) {
        @Override
        public void handleMessage(
            String aType,
            String aMessageId,
            Date aTimestamp,
            String aTextMessage,
            long aDeliveryTag,
            boolean isRedelivery)
        throws Exception {
            // tenantId, sprintId, backlogItemIdをJSONから取得する
            String tenantId = ...
            String sprintId = ...
            String backlogItemId = ...
            
            ApplicationServiceRegistry
                    .sprintService()
                    .commitBacklogItem(
                            tenantId, sprintId, backlogItemId);
        }
    });
```

* このサンプルではBacklogItemをSprintにコミットする操作は冪等なので、重複排除のことは考えなくていい。
* このサブスクライバがこのイベントをどうやって受け取るかについては、本章の後半で説明をする

##### 集約の利用

- システムのユーザが何らかのアクションを起こしたことを表すものとして、イベントを集約としてモデリングし、リポジトリに保持させることができる
- イベントは何らかの出来事を表すので、リポジトリはその集約の削除を許可はしないだろう
- この場合、イベントは不変ではあるが、一意な識別子を割り当てても構わない。
- イベントをこの方式でモデリングする場合は、イベントをリポジトリに追加するとづ時に、メッセージング基盤を使ってパブリッシュすることもできる。
    - ドメインサービスを呼び、イベントを作り、それをリポジトリに追加して、メッージング基盤を利用して、パブリッシュする

##### 識別子
* イベントに一意な識別子を用意すべき理由
  * イベントを他と区別して特定するため
  * 外部のコンテキストにイベントを出版するとき、場合によっては同じメッセージを複数回配送することもありえる。受け取るサブスクライバ側ですでに処理済みのメッセージを無視するのに識別子を使用する。

### :question:疑問点
- P282の「このサンプルではイベントの重複排除のことは考えなくてもいい。というのも、BacklogItemをSprintにコミットする操作は、冪等な操作だからである。もしそのBacklogItemがすでにSprintにコミット済みであったとして、同じスプリントへの二度目のコミットは無視される」という内容がよくわからない。
    - P281のサンプルコードを見る限り、二度目のコミットも行われそうに見える（重複なので同じコミットを2回する）

### :memo:書記欄
- 2回もコミットしてもOKっていう話。
    - 結果が冪等であるから、内部的にアップデートしているけど無視している

- 「同じスプリントへの二度目のコミットは無視される」というのは、無視して処理しない、ではなく、同じ内容を2回書く (上書きする) ので、結果的に無視したのと同じ。という意味。
- カウントを+3する←冪等ではない。カウントを10にする←冪等
- 結果が冪等になってればOKですね
- イベントバージョンをみて、無視するもよし、同じ値で上書きするもよし。処理が冪等で作られていればOKですね

---

## 8.3 ドメインモデルからのイベントの発行

### :books:概要

- ドメインモデルの情報を、メッセージング基盤のミドルウェア（＝インフラストラクチャ）には漏らさないようにする
- この章では、インフラストラクチャとの結合を完全に回避する手法を利用する

- 最もシンプルかつ効率的なのは、軽量なオブザーバを作る方法である
    - オブザーバパターン。Pub/Subのこと
    - イベントを購読したり、発行したりする際に、ネットワークが絡まないのがシンプルな理由

* パブリッシャーサブスクライバー(出版・購読)パターンを使った実装。

```
// ユーザーからのリクエストを受け取った際に。フィルターコンポーネントにて
DomainEventPublisher.instance().reset();
...
// 後に、アプリケーションサービスが同じリクエストを処理する際に
DomainEventPublisher.instance().subscribe(subscriber);
```

```
public class BacklogItem extends ConcurrencySafeEntity {
    ...
    // 集約が集約イベントを発行するコード
    public void commitTo(Sprint aSprint) {
        ...
        DomainEventPublisher
            .instance()
            .publish(new BacklogItemCommitted(
                    this.tenantId(),
                    this.backlogItemId(),
                    this.sprintId()));
    }
    ...
}
```

* サブスクライバをドメインイベントに登録するのは、一般論としてはアプリケーションサービスが登録する。ときにはドメインサービスがその役割を担うこともある。

* サブスクライバの処理の例:
  * 1) メール送信
  * 2) イベントストアにドメインイベントを格納
  * 3) メッセージング基盤を使ってドメインイベントを転送
  * 2), 3) の場合は通常、この例のようなユースケースごとのアプリケーションサービスによるイベント処理は行わない。単一のサブスクライバコンポーネントを使って対応するだろう。

* サブスクライバがやってはいけないこと
    * 別の集約のインスタンスを取得し、そのコマンドを実行して状態を変更すること。
    * 理由: **単一のトランザクション内では単一の集約のインスタンスだけを変更する** という経験則に反するため。

### :question:疑問点


### :memo:書記欄


---

## 8.4 リモートの境界づけられたコンテキストへの通知

### :books:概要

- リモートの境界づけられたコンテキストにイベントを届けるいくつかの方法のなかで、真っ先に思いつくのはメッセージングを使う方法だ。
- メッセージングに使えるコンポーネントには様々な物がある。
    - RabbitMQ, Akka, NServiceBus などのメッセージングミドルウェア
    - REST を使った自作の仕組み
- どの方法を選ぶのかの決め手になるのは、関係するチームが目指す予算や好み、機能要件、非機能要件だ。

##### ■ メッセージング基盤の整合性 (P.291)
- メッセージングで結果整合性を用いるとき、少なくとも2つのメカニズムは、常に整合性を保つ必要がある。
    - ドメインモデルが使う永続化ストア
    - モデルから発行されたイベントを、メッセージング基盤が転送する際に使う永続化ストア
- これらの整合性を保つことで、モデルへの変更が永続化されたときに、イベントが配送されることが保証される。
- モデルとイベントの整合性を保ちつつ永続化を行う方法として、基本的には以下の三通りが考えられる。
    1. ドメインモデルとメッセージング基盤が、**永続化ストアを共有**する。
    2. ドメインモデルの永続化ストアと、メッセージング用の永続化ストアを、グローバルなXAトランザクションで制御する(**2層コミット**)。
    3. イベント用の特別なストレージを、ドメインモデルが使っているのと同じデータストア内に用意する(**イベントストア**)。

- 本章のサンプルコードは、3番目の手法を使用している

##### ■ 自立型のサービス及びシステム (P.292)
- ドメインイベントを使うと、任意の数の業務システムを**自立型のサービス及びシステム**として設計できる。
- RPCを避けると、ほかシステムからの高いレベルの独立性が達成される。
    - RPC はリモートのシステムへのリクエストが成功しなければ処理が完結しないため。
    - リモートのシステムは障害や負荷などによって使えなくなる可能性がある。
      従って、RPCで依存するシステムが増えるほど、システムが使えなくなる可能性が高まる。
      
- 他のシステムを呼び出すのではなく、非同期メッセージングでシステム間の独立性を保ち、自立させる
    - 社内に散在する境界づけられたコンテキストからのドメインイベントを運ぶメッセージを受信するたびに、自分たちの境界づけられたコンテキストにおけるイベントの意味を反映した振る舞いを、モデル上で実行する
    - もし、外部のモデルの概念やオブジェクトなどをほぼそのまま手元にコピーすることになりそうなら、RPCを使うことを検討すべき
    - ケースバイケースだが、安易にRPCをに頼ってしまわないことをオススメする

##### ■ 遅延の許容範囲 (P.293)
- 結果整合性が達成されるまでが、どの程度の時間で用意できればいいのかドメインエキスパートに確認すると、数分～数時間、中には数日遅れでもまったく気にならないと言われることも多い。
- どんなドメインであっても、常に一貫性を確保すべきだとは思い込まないようにするべきだ。

- こんな問いかけをすると、即時に一貫性が保たれることなどなかったと、気づきが得られやすい「もし今コンピュータが使えなくなったら、どうやって作業を進めますか？」
    - 紙ベースの業務を思い起こせば、どんなシンプルな業務であっても、即時に一貫性が保たれることなどなかったはずである

### :question:疑問点
- 「ドメインモデルが使う永続化ストア、モデルから発行されたイベントをメッセージング基盤が転送する際に使う永続化ストア」は結果整合性ではなく、**整合性**を保たなければいけない。と読み取ったが、それでよい？ :+1: 
- P.291の「メッセージング基盤が転送の際に使う永続化ストア」とは具体的にはどういうもの？

### :memo:書記欄
- 同じ認識
- 結果整合性を
- イベントストアと、DBが別になるか一緒になるか
    - イベントが発行されたという
- 大事なことは、ステートとイベントの整合性を保つ？
- 起こったイベントが全て発行されているって整合性がないとまずいよねって事が書いてあるのでは？
- モデルへの変更が永続化された時に、イベントが配送されることが保証されるじゃないかなと。ここに書いてあることはここまでしか言ってない気がする
- RDBMSを使っている人は、トランザクションを書き込んでいる人は、その恩恵に預かれる。①③はそれ。②は、まぁまぁ難しくなる。だからこそ、RDBMSを使う
- イベントが欠落すると、履歴として成立しない。確実に記録しなければいけない。


---

## 8.5 イベントストア

### :books:概要

>イベントストア
>発生したイベントの履歴をストレージに記録する方法

イベントストアに格納したイベント情報を利用者に公開することで過去履歴を活用する。利用側は必要に応じてイベント発生元のドメインモデルを取得して、自分の境界づけられたコンテキストに取り込む。

イベントストアを使うことで次のメリットが得られる

- メッセージ基盤を通してドメインイベントを発行するキューとして使用できる
    - 複数の境界付けされたコンテキストの統合に利用できる
    - リモートのサブスクライバが自分のコンテキストの必要に応じてイベントに反応する
- 同じイベントストアを使って、RESTベースのイベント通知をクライアントに提供できる
- モデルで発生したイベントを全て履歴として記録できる
    - 調査や監査に利用する
    - イベントストアは単なる監査ログではないため、コマンドを全て記録しているわけではない
- イベントストアのデータを使って、分析や予測ができる
    - 後から集計が可能
- イベントを用いてリポジトリの構築を行い、集約の再構築ができる
    - イベントソーシングにてデータパッチやデバッグも可能
- ロールバック及び特定のコマンドの削除が可能になる
    - 特定のコマンドの削除はロールバック後、特定のコマンドの実行を行わない
    - 特定のコマンドを実行しないことで取り消しと同じ処理を実現する

イベントストアを実現する際には、サブスクライバを作成して、モデルが発行する全てのイベントを受け取る事から始める。

### :question:疑問点
- P.297 の Spring + AOP のサンプルで、アプリケーションサービスの実行の @Before で Subscribe をねじ込んでいるけど、毎回のリクエストで Subscribe して大丈夫なんだろうか？ それともSpring だと1回しか呼ばれないのかな？ Spring に詳しい人居たら教えて下さい。
- P.298-299で、最終的にイベントをシリアライズして保管をしているけどその理由ってなんだろう？　

### :memo:書記欄
- スレッド内でサブスクライバが登録されるので、reset()が走るので、subscribe を@Beforeで読んでも大丈夫。

- 楽だから
- NoSQL使おうとすると

---


## 8.6 格納したイベントの転送のためのアーキテクチャスタイル

### :books:概要

イベントストアにイベントを格納すれば、そのイベントに関心のあるシステムへの通知のためにイベントを転送することが出来る。格納したイベントの活用方法として2つ検討する

1. RESTfulなリソースを提供してクライアントからの問い合わせに答える
   - Publisher-Subscriber形式と同じ結果が得れる
2. メッセージングミドルウェアのトピック/エクスチェンジを使ってメッセージを送信する

#### RESTfulなリソースによる通知の発行

REST方式によるイベントの通知が成功させるためには、Publisher-Subscriber形式の基本前提上に構築されたシステムで使う必要がある。

- 多数のクライアントが、たった一つの既知のURIを使って同じ通知を要求する場合、RESTfulな方式は成功する
    - ポーリングするコンシューマの数だけ通知が散開する
    - プルモデルで構築することで柔軟性を持たせる
- ごく少数のコンシューマが複数のプロデューサーから所定の手順でりソースを取得しないと、一つのタスクを実行できない場合は、RESTfulな手法があっという間に苦になる
    - 多数のプロデューサーがごく少数のコンシューマに通知を送る必要がある
    - また、その送信順序が重要になる
    - そのため、ポーリング方式ではなく、キュー方式で構築するべき

ここでは、プルモデルのPublisher-Subscriberを構築するため、従来方式のメッセージング基盤を用いて発行の対局に位置する。

#### メッセージングミドルウェアによる通知の発行

メッセージングミドルウェアを使うことでRESTを容易に実現することが出来る

>[RabbitMQ](http://www.rabbitmq.com/)がメッセージングミドルウェアの代表例

[RabbitMQのPublish/Subscribe](http://www.rabbitmq.com/tutorials/tutorial-three-dotnet.html)を利用することで細かな処理をミドルウェアに移譲することが出来る



##### RabbitMQを用いたイベントの送受信

RabbitMQはAMQP(Advanced Message Queuing Protocol)というメッセージングプロトコルに準拠した、オープンソースのミドルウェアである。AMQPとは、キューイングやルーティング(P2Pや出版購読モデル)、信頼性、セキュリティといった機能が定義されているプロトコルである。RabbitMQの場合、サーバーをインストールし、クライアントAPIを介してアクセスするだけで、メッセージの登録や取得が可能になる。

RabbitMQを用いてイベントを送信する手順は以下の通り。

1. イベントストアからイベントを一意な識別子でソートして取得する
2. 取得したリストを昇順にたどり、それぞれをエクスチェンジに送信する
3. メッセージの発行に成功したら、そのイベントがエクスチェンジに発行されたことを記録する

RabbitMQでは、エクスチェンジ(メッセージを送付する機能)にデータを連携するだけでデータを配信できる。配送方式や配送先の選択はRabbitMQ側で制御できる。

##### メッセージ基盤を使う時の注意点

メッセージ基盤を使う時の注意点として、次の2点を考慮しておく必要がある。

- **メッセージが重複処理される可能性**がある
    - 送信側でメッセージを送信した後で、ドメインモデル側のDBのコミットに失敗してしまう
- 配送順番が保証されない

このような問題に対して、購読側にて複数回取り込んでも問題ないように実装しなければならない。通常、メッセージID(イベントID)を使用して、どこまでメッセージを処理したかを記録しておく。

最近は、AWSやAzureなどのクラウドサービスでもイベントの送受信機能やキューの機能が提供されている。

>サーバー管理の手間が不要で使い勝手も良いため、システム連携を行う場合の選択肢に入れるべき。それぞれの、機能要件/性能/予算などのバランスから選択する。

### :question:疑問点


### :memo:書記欄


---

## 8.7 実装

### :books:概要

イベントストアの実装例としては、イベントストア(EventStore)インタフェースを利用してイベントの履歴情報をストレージへ格納する。イベントストアのストレージはMySQLのようなRDBや、LevelDBのようなNoSQLなどから最適な製品を選択する。どのストレージを選択するにしても、ドメインモデルの情報とイベント履歴の整合性が保たれるように注意する。

ストレージにはストアドイベント(StoredEvent)クラスをシリアライズした内容を格納する。これらはドメインイベント(DomainEvent)インターフェースを実装するイベントクラスから変換する。

#### イベントの重複排除

メッセージングシステムを通じて発行された一つのメッセージが、サブスクライバに複数回配送される可能性がある場合、重複排除を検討する。

1. RabbitMQが、新たに送信されたメッセージをいくつかのサブスクライバに配送する
2. サブスクライバが、そのメッセージを処理する
3. メッセージの受領と処理の完了の応答を返す前に、サブスクライバが異常終了する
4. RabbitMQが、受領報告を届かなかったメッセージを再送する

これ以外には、イベントストアの外部に向けて発行する際にメッセージングシステムとイベントストアが永続化メカニズムを共有しておらず、さらに、イベントストアとメッセージングシステムへの変更をアトミックに行うような、グローバルなトランザクションにも対応していない場合に発生する。

メッセージの重複排除を実現するためには、サブスクライバの操作が冪等(ある操作を1回行っても複数回行っても結果が同じであること)になるようにモデリングをする。ただし、冪等性を実現することは非常に難しい。つまり、状態を持たせることが難しくなる。もしくは、冪等性を実現するために構造を複雑にしなければならなくなる。

そのため、サブスクライバ/レシーバ自体を冪等になるように設計する。ここでは、重複したメッセージに対応する操作を実行しないように実装を変更する。

### :question:疑問点


### :memo:書記欄


---

## 8.8 まとめ

### :books:概要

- ドメインイベントとは何なのか、いつそれを使うべきなのか、そしてなぜ使うべきなのかを学んだ
- イベントをオブジェクトとしてモデリングする方法と、それを一意にしきべつしなければいけない場面について調べた
- イベントが集約の特性を持つべき場面、そしてシンプルな値をベースにしたイベントで充分な場面について、それぞれ検討した
- 軽量な出版・購読型のコンポーネントをモデル内で使う方法を見た。
- どのコンポーネントがイベントを出版するのか、そしてどのコンポーネントがそれを購読するかを発見した
- イベントストアを開発したくなる理由とその作り方、使い方の概要を調べた
- 境界づけられたコンテキストの外部にイベントを出版するための、2つの手法を学んだ。
- メッセージを購読する側のシステムが、メッセージの重複を除去する方法を学んだ

### :question:疑問点


### :memo:書記欄
- 情報は多くないけど、書き込む時間が長そうなので、ES使いたいけど何か注意点がある？
    - 非同期更新のために、イベント情報だけ記録しておく、という事例ですね。

- 注意点
    - JobとQueingとCQRSを実現すれば、やればいいのではないか。
    - Pub / Subで切り分ける。
    - ESを使おうと結構コストが掛かる

- イベントソーシングはPub / Subではない。
    - ES使うメリットとしては、イベントをソースとする。
    - イベントをソースで発行する表現
    - イベントがソースとなっていけない。キモ。すべての状態がイベントがフックにならなければいけない。
    
- 保守チームがあったとしたら、DB書き換えても成立しないので、打ち消し用のイベントを作っておかないといけない
- イベントストアのスナップショットを取る仕組みを作るときに、フルスクラッチで作るのが大変。
- メンバーが付いてこれる問題がある

- ESのメリット
    - イベントを巻き戻すことができる
    - それによって、自由なモデルを作ることができるのがメリット
- ESのデメリット
    - メンバーが付いてこれない。



---


## 輪読会感想ふりかえり用

## 読書会進め方ふりかえり用

## その他、メモとか用の領域


